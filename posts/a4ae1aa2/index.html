<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.2">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":true,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="Caffeine是一个高性能，高命中率，低内存占用，near optimal的本地缓存，本文将重点讲解Caffeine的高性能设计，以及对应部分的源码分析。">
<meta property="og:type" content="article">
<meta property="og:title" content="Caffeine高性能设计剖析">
<meta property="og:url" content="http://example.com/posts/a4ae1aa2/index.html">
<meta property="og:site_name" content="xuezc&#39;s home">
<meta property="og:description" content="Caffeine是一个高性能，高命中率，低内存占用，near optimal的本地缓存，本文将重点讲解Caffeine的高性能设计，以及对应部分的源码分析。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/images/Caffeine%E9%AB%98%E6%80%A7%E8%83%BD%E8%AE%BE%E8%AE%A1%E5%89%96%E6%9E%90__0.png">
<meta property="og:image" content="http://example.com/images/Caffeine%E9%AB%98%E6%80%A7%E8%83%BD%E8%AE%BE%E8%AE%A1%E5%89%96%E6%9E%90__1.png">
<meta property="og:image" content="http://example.com/images/Caffeine%E9%AB%98%E6%80%A7%E8%83%BD%E8%AE%BE%E8%AE%A1%E5%89%96%E6%9E%90__2.png">
<meta property="og:image" content="http://example.com/images/Caffeine%E9%AB%98%E6%80%A7%E8%83%BD%E8%AE%BE%E8%AE%A1%E5%89%96%E6%9E%90__3.png">
<meta property="og:image" content="http://example.com/images/Caffeine%E9%AB%98%E6%80%A7%E8%83%BD%E8%AE%BE%E8%AE%A1%E5%89%96%E6%9E%90__4.png">
<meta property="og:image" content="http://example.com/images/Caffeine%E9%AB%98%E6%80%A7%E8%83%BD%E8%AE%BE%E8%AE%A1%E5%89%96%E6%9E%90__5.png">
<meta property="og:image" content="http://example.com/images/Caffeine%E9%AB%98%E6%80%A7%E8%83%BD%E8%AE%BE%E8%AE%A1%E5%89%96%E6%9E%90__6.png">
<meta property="og:image" content="http://example.com/images/Caffeine%E9%AB%98%E6%80%A7%E8%83%BD%E8%AE%BE%E8%AE%A1%E5%89%96%E6%9E%90__7.png">
<meta property="article:published_time" content="2019-12-17T09:01:00.000Z">
<meta property="article:modified_time" content="2023-03-27T06:18:53.485Z">
<meta property="article:author" content="xuezc">
<meta property="article:tag" content="java">
<meta property="article:tag" content="cache">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/images/Caffeine%E9%AB%98%E6%80%A7%E8%83%BD%E8%AE%BE%E8%AE%A1%E5%89%96%E6%9E%90__0.png">

<link rel="canonical" href="http://example.com/posts/a4ae1aa2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Caffeine高性能设计剖析 | xuezc's home</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">xuezc's home</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">首页</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/posts/a4ae1aa2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="xuezc">
      <meta itemprop="description" content="在这里，你会了解的更多，更透切">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="xuezc's home">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Caffeine高性能设计剖析
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-12-17 17:01:00" itemprop="dateCreated datePublished" datetime="2019-12-17T17:01:00+08:00">2019-12-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-03-27 14:18:53" itemprop="dateModified" datetime="2023-03-27T14:18:53+08:00">2023-03-27</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/caffeine/" itemprop="url" rel="index"><span itemprop="name">caffeine</span></a>
                </span>
            </span>

          
            <div class="post-description">Caffeine是一个高性能，高命中率，低内存占用，near optimal的本地缓存，本文将重点讲解Caffeine的高性能设计，以及对应部分的源码分析。</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h2><p><a target="_blank" rel="noopener" href="https://github.com/ben-manes/caffeine">Caffeine</a>是一个高性能，高命中率，低内存占用，near optimal 的本地缓存，简单来说它是Guava Cache的优化加强版，有些文章把Caffeine称为“新一代的缓存”、“现代缓存之王”。本文将重点讲解Caffeine的高性能设计，以及对应部分的源码分析。</p>
<h2 id="与Guava-Cache比较"><a href="#与Guava-Cache比较" class="headerlink" title="与Guava Cache比较"></a>与Guava Cache比较</h2><p>如果你对Guava Cache还不理解的话，可以点击<a href="/2019/07/28/Guava-Cache%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%8F%8A%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/" title="这里">这里</a>来看一下我之前写过关于Guava Cache的文章。</p>
<p>大家都知道，Spring5即将放弃掉Guava Cache作为缓存机制，而改用Caffeine作为新的本地Cache的组件，这对于Caffeine来说是一个很大的肯定。为什么Spring会这样做呢？其实在Caffeine的<a target="_blank" rel="noopener" href="https://github.com/ben-manes/caffeine/wiki/Benchmarks">Benchmarks</a>里给出了好靓仔的数据，对读和写的场景，还有跟其他几个缓存工具进行了比较，Caffeine的性能都表现很突出。</p>
<p><img src="/images/Caffeine%E9%AB%98%E6%80%A7%E8%83%BD%E8%AE%BE%E8%AE%A1%E5%89%96%E6%9E%90__0.png" alt="upload successful"></p>
<h2 id="使用Caffeine"><a href="#使用Caffeine" class="headerlink" title="使用Caffeine"></a>使用Caffeine</h2><p>Caffeine为了方便大家使用以及从Guava Cache切换过来（很有针对性啊～），借鉴了Guava Cache大部分的概念（诸如核心概念Cache、LoadingCache、CacheLoader、CacheBuilder等等），对于Caffeine的理解只要把它当作Guava Cache就可以了。</p>
<p>使用上，大家只要把Caffeine的包引进来，然后换一下cache的实现类，基本应该就没问题了。这对与已经使用过Guava Cache的同学来说没有任何难度，甚至还有一点熟悉的味道，如果你之前没有使用过Guava Cache，可以查看Caffeine的<a target="_blank" rel="noopener" href="https://github.com/ben-manes/caffeine/wiki">官方API说明文档</a>，其中Population，Eviction，Removal，Refresh，Statistics，Cleanup，Policy等等这些特性都是跟Guava Cache基本一样的。</p>
<p>下面给出一个例子说明怎样创建一个Cache：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> LoadingCache&lt;String, String&gt; cache = Caffeine.newBuilder()</span><br><span class="line">            <span class="comment">//最大个数限制</span></span><br><span class="line">            .maximumSize(<span class="number">256L</span>)</span><br><span class="line">            <span class="comment">//初始化容量</span></span><br><span class="line">            .initialCapacity(<span class="number">1</span>)</span><br><span class="line">            <span class="comment">//访问后过期（包括读和写）</span></span><br><span class="line">            .expireAfterAccess(<span class="number">2</span>, TimeUnit.DAYS)</span><br><span class="line">            <span class="comment">//写后过期</span></span><br><span class="line">            .expireAfterWrite(<span class="number">2</span>, TimeUnit.HOURS)</span><br><span class="line">            <span class="comment">//写后自动异步刷新</span></span><br><span class="line">            .refreshAfterWrite(<span class="number">1</span>, TimeUnit.HOURS)</span><br><span class="line">            <span class="comment">//记录下缓存的一些统计数据，例如命中率等</span></span><br><span class="line">            .recordStats()</span><br><span class="line">            <span class="comment">//cache对缓存写的通知回调</span></span><br><span class="line">            .writer(<span class="keyword">new</span> <span class="title class_">CacheWriter</span>&lt;Object, Object&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(<span class="meta">@NonNull</span> Object key, <span class="meta">@NonNull</span> Object value)</span> &#123;</span><br><span class="line">                    log.info(<span class="string">&quot;key=&#123;&#125;, CacheWriter write&quot;</span>, key);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(<span class="meta">@NonNull</span> Object key, <span class="meta">@Nullable</span> Object value, <span class="meta">@NonNull</span> RemovalCause cause)</span> &#123;</span><br><span class="line">                    log.info(<span class="string">&quot;key=&#123;&#125;, cause=&#123;&#125;, CacheWriter delete&quot;</span>, key, cause);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">            <span class="comment">//使用CacheLoader创建一个LoadingCache</span></span><br><span class="line">            .build(<span class="keyword">new</span> <span class="title class_">CacheLoader</span>&lt;String, String&gt;() &#123;</span><br><span class="line">                <span class="comment">//同步加载数据</span></span><br><span class="line">                <span class="meta">@Nullable</span></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> String <span class="title function_">load</span><span class="params">(<span class="meta">@NonNull</span> String key)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="string">&quot;value_&quot;</span> + key;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//异步加载数据</span></span><br><span class="line">                <span class="meta">@Nullable</span></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> String <span class="title function_">reload</span><span class="params">(<span class="meta">@NonNull</span> String key, <span class="meta">@NonNull</span> String oldValue)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="string">&quot;value_&quot;</span> + key;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br></pre></td></tr></table></figure>

<p>更多从Guava Cache迁移过来的使用说明，请看<a target="_blank" rel="noopener" href="https://github.com/ben-manes/caffeine/wiki/Guava">这里</a></p>
<h2 id="Caffeine的高性能设计"><a href="#Caffeine的高性能设计" class="headerlink" title="Caffeine的高性能设计"></a>Caffeine的高性能设计</h2><p>判断一个缓存的好坏最核心的指标就是命中率，影响缓存命中率有很多因素，包括业务场景、淘汰策略、清理策略、缓存容量等等。如果作为本地缓存， 它的性能的情况，资源的占用也都是一个很重要的指标。下面</p>
<p>我们来看看Caffeine在这几个方面是怎么着手的，如何做优化的。</p>
<p>（注：本文不会分析Caffeine全部源码，只会对核心设计的实现进行分析，但我建议读者把Caffeine的源码都涉猎一下，有个overview才能更好理解本文。如果你看过Guava Cache的源码也行，代码的数据结构和处理逻辑很类似的。</p>
<p>源码基于：caffeine-2.8.0.jar）</p>
<h3 id="W-TinyLFU整体设计"><a href="#W-TinyLFU整体设计" class="headerlink" title="W-TinyLFU整体设计"></a>W-TinyLFU整体设计</h3><p>上面说到淘汰策略是影响缓存命中率的因素之一，一般比较简单的缓存就会直接用到LFU(Least Frequently Used，即最不经常使用)或者LRU(Least Recently Used，即最近最少使用)，而Caffeine就是使用了W-TinyLFU算法。</p>
<p>W-TinyLFU看名字就能大概猜出来，它是LFU的变种，也是一种缓存淘汰算法。那为什么要使用W-TinyLFU呢？</p>
<h4 id="LRU和LFU的缺点"><a href="#LRU和LFU的缺点" class="headerlink" title="LRU和LFU的缺点"></a>LRU和LFU的缺点</h4><ul>
<li><p>LRU实现简单，在一般情况下能够表现出很好的命中率，是一个“性价比”很高的算法，平时也很常用。虽然LRU对突发性的稀疏流量（sparse bursts）表现很好，但同时也会产生缓存污染，举例来说，如果偶然性的要对全量数据进行遍历，那么“历史访问记录”就会被刷走，造成污染。</p>
</li>
<li><p>如果数据的分布在一段时间内是固定的话，那么LFU可以达到最高的命中率。但是LFU有两个缺点，第一，它需要给每个记录项维护频率信息，每次访问都需要更新，这是个巨大的开销；第二，对突发性的稀疏流量无力，因为前期经常访问的记录已经占用了缓存，偶然的流量不太可能会被保留下来，而且过去的一些大量被访问的记录在将来也不一定会使用上，这样就一直把“坑”占着了。</p>
</li>
</ul>
<p>无论LRU还是LFU都有其各自的缺点，不过，现在已经有很多针对其缺点而改良、优化出来的变种算法。</p>
<h4 id="TinyLFU"><a href="#TinyLFU" class="headerlink" title="TinyLFU"></a>TinyLFU</h4><p>TinyLFU就是其中一个优化算法，它是专门为了解决LFU上述提到的两个问题而被设计出来的。</p>
<p>解决第一个问题是采用了Count–Min Sketch算法。</p>
<p>解决第二个问题是让记录尽量保持相对的“新鲜”（Freshness Mechanism），并且当有新的记录插入时，可以让它跟老的记录进行“PK”，输者就会被淘汰，这样一些老的、不再需要的记录就会被剔除。</p>
<p>下图是TinyLFU设计图（来自官方）</p>
<p><img src="/images/Caffeine%E9%AB%98%E6%80%A7%E8%83%BD%E8%AE%BE%E8%AE%A1%E5%89%96%E6%9E%90__1.png" alt="upload successful"></p>
<h5 id="统计频率Count–Min-Sketch算法"><a href="#统计频率Count–Min-Sketch算法" class="headerlink" title="统计频率Count–Min Sketch算法"></a>统计频率Count–Min Sketch算法</h5><p>如何对一个key进行统计，但又可以节省空间呢？（不是简单的使用HashMap，这太消耗内存了），注意哦，不需要精确的统计，只需要一个近似值就可以了，怎么样，这样场景是不是很熟悉，如果你是老司机，或许已经联想到布隆过滤器（Bloom Filter）的应用了。</p>
<p>没错，将要介绍的Count–Min Sketch的原理跟Bloom Filter一样，只不过Bloom Filter只有0和1的值，那么你可以把Count–Min Sketch看作是“数值”版的Bloom Filter。</p>
<p>更多关于Count–Min Sketch的介绍请自行搜索。</p>
<p>在TinyLFU中，近似频率的统计如下图所示：</p>
<p><img src="/images/Caffeine%E9%AB%98%E6%80%A7%E8%83%BD%E8%AE%BE%E8%AE%A1%E5%89%96%E6%9E%90__2.png" alt="upload successful"></p>
<p>对一个key进行多次hash函数后，index到多个数组位置后进行累加，查询时取多个值中的最小值即可。</p>
<p>Caffeine对这个算法的实现在<code>FrequencySketch</code>类。但Caffeine对此有进一步的优化，例如Count–Min Sketch使用了二维数组，Caffeine只是用了一个一维的数组；再者，如果是数值类型的话，这个数需要用int或long来存储，但是Caffeine认为缓存的访问频率不需要用到那么大，只需要15就足够，一般认为达到15次的频率算是很高的了，而且Caffeine还有另外一个机制来使得这个频率进行衰退减半（下面就会讲到）。如果最大是15的话，那么只需要4个bit就可以满足了，一个long有64bit，可以存储16个这样的统计数，Caffeine就是这样的设计，使得存储效率提高了16倍。</p>
<p>Caffeine对缓存的读写（<code>afterRead</code>和<code>afterWrite</code>方法）都会调用<code>onAccess</code>s方法，而onAccess方法里有一句：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">frequencySketch().increment(key);</span><br></pre></td></tr></table></figure>

<p>这句就是追加记录的频率，下面我们看看具体实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//FrequencySketch的一些属性</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//种子数</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span>[] SEED = &#123; <span class="comment">// A mixture of seeds from FNV-1a, CityHash, and Murmur3</span></span><br><span class="line">    <span class="number">0xc3a5c85c97cb3127L</span>, <span class="number">0xb492b66fbe98f273L</span>, <span class="number">0x9ae16a3b2f90404fL</span>, <span class="number">0xcbf29ce484222325L</span>&#125;;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">RESET_MASK</span> <span class="operator">=</span> <span class="number">0x7777777777777777L</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">ONE_MASK</span> <span class="operator">=</span> <span class="number">0x1111111111111111L</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> sampleSize;</span><br><span class="line"><span class="comment">//为了快速根据hash值得到table的index值的掩码</span></span><br><span class="line"><span class="comment">//table的长度size一般为2的n次方，而tableMask为size-1，这样就可以通过&amp;操作来模拟取余操作，速度快很多，老司机都知道</span></span><br><span class="line"><span class="type">int</span> tableMask;</span><br><span class="line"><span class="comment">//存储数据的一维long数组</span></span><br><span class="line"><span class="type">long</span>[] table;</span><br><span class="line"><span class="type">int</span> size;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Increments the popularity of the element if it does not exceed the maximum (15). The popularity</span></span><br><span class="line"><span class="comment"> * of all elements will be periodically down sampled when the observed events exceeds a threshold.</span></span><br><span class="line"><span class="comment"> * This process provides a frequency aging to allow expired long term entries to fade away.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e the element to add</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">(<span class="meta">@NonNull</span> E e)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (isNotInitialized()) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//根据key的hashCode通过一个哈希函数得到一个hash值</span></span><br><span class="line">  <span class="comment">//本来就是hashCode了，为什么还要再做一次hash？怕原来的hashCode不够均匀分散，再打散一下。</span></span><br><span class="line">  <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> spread(e.hashCode());</span><br><span class="line">  <span class="comment">//这句光看有点难理解</span></span><br><span class="line">  <span class="comment">//就如我刚才说的，Caffeine把一个long的64bit划分成16个等分，每一等分4个bit。</span></span><br><span class="line">  <span class="comment">//这个start就是用来定位到是哪一个等分的，用hash值低两位作为随机数，再左移2位，得到一个小于16的值</span></span><br><span class="line">  <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> (hash &amp; <span class="number">3</span>) &lt;&lt; <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//indexOf方法的意思就是，根据hash值和不同种子得到table的下标index</span></span><br><span class="line">  <span class="comment">//这里通过四个不同的种子，得到四个不同的下标index</span></span><br><span class="line">  <span class="type">int</span> <span class="variable">index0</span> <span class="operator">=</span> indexOf(hash, <span class="number">0</span>);</span><br><span class="line">  <span class="type">int</span> <span class="variable">index1</span> <span class="operator">=</span> indexOf(hash, <span class="number">1</span>);</span><br><span class="line">  <span class="type">int</span> <span class="variable">index2</span> <span class="operator">=</span> indexOf(hash, <span class="number">2</span>);</span><br><span class="line">  <span class="type">int</span> <span class="variable">index3</span> <span class="operator">=</span> indexOf(hash, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//根据index和start(+1, +2, +3)的值，把table[index]对应的等分追加1</span></span><br><span class="line">  <span class="comment">//这个incrementAt方法有点难理解，看我下面的解释</span></span><br><span class="line">  <span class="type">boolean</span> <span class="variable">added</span> <span class="operator">=</span> incrementAt(index0, start);</span><br><span class="line">  added |= incrementAt(index1, start + <span class="number">1</span>);</span><br><span class="line">  added |= incrementAt(index2, start + <span class="number">2</span>);</span><br><span class="line">  added |= incrementAt(index3, start + <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//这个reset等下说</span></span><br><span class="line">  <span class="keyword">if</span> (added &amp;&amp; (++size == sampleSize)) &#123;</span><br><span class="line">    reset();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Increments the specified counter by 1 if it is not already at the maximum value (15).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> i the table index (16 counters)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> j the counter to increment</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> if incremented</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">incrementAt</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">  <span class="comment">//这个j表示16个等分的下标，那么offset就是相当于在64位中的下标（这个自己想想）</span></span><br><span class="line">  <span class="type">int</span> <span class="variable">offset</span> <span class="operator">=</span> j &lt;&lt; <span class="number">2</span>;</span><br><span class="line">  <span class="comment">//上面提到Caffeine把频率统计最大定为15，即0xfL</span></span><br><span class="line">  <span class="comment">//mask就是在64位中的掩码，即1111后面跟很多个0</span></span><br><span class="line">  <span class="type">long</span> <span class="variable">mask</span> <span class="operator">=</span> (<span class="number">0xfL</span> &lt;&lt; offset);</span><br><span class="line">  <span class="comment">//如果&amp;的结果不等于15，那么就追加1。等于15就不会再加了</span></span><br><span class="line">  <span class="keyword">if</span> ((table[i] &amp; mask) != mask) &#123;</span><br><span class="line">    table[i] += (<span class="number">1L</span> &lt;&lt; offset);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns the table index for the counter at the specified depth.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> item the element&#x27;s hash</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> i the counter depth</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the table index</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">indexOf</span><span class="params">(<span class="type">int</span> item, <span class="type">int</span> i)</span> &#123;</span><br><span class="line">  <span class="type">long</span> <span class="variable">hash</span> <span class="operator">=</span> SEED[i] * item;</span><br><span class="line">  hash += hash &gt;&gt;&gt; <span class="number">32</span>;</span><br><span class="line">  <span class="keyword">return</span> ((<span class="type">int</span>) hash) &amp; tableMask;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Applies a supplemental hash function to a given hashCode, which defends against poor quality</span></span><br><span class="line"><span class="comment"> * hash functions.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">spread</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">  x = ((x &gt;&gt;&gt; <span class="number">16</span>) ^ x) * <span class="number">0x45d9f3b</span>;</span><br><span class="line">  x = ((x &gt;&gt;&gt; <span class="number">16</span>) ^ x) * <span class="number">0x45d9f3b</span>;</span><br><span class="line">  <span class="keyword">return</span> (x &gt;&gt;&gt; <span class="number">16</span>) ^ x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>知道了追加方法，那么读取方法<code>frequency</code>就很容易理解了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns the estimated number of occurrences of an element, up to the maximum (15).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e the element to count occurrences of</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the estimated number of occurrences of the element; possibly zero but never negative</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@NonNegative</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">frequency</span><span class="params">(<span class="meta">@NonNull</span> E e)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (isNotInitialized()) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//得到hash值，跟上面一样</span></span><br><span class="line">  <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> spread(e.hashCode());</span><br><span class="line">  <span class="comment">//得到等分的下标，跟上面一样</span></span><br><span class="line">  <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> (hash &amp; <span class="number">3</span>) &lt;&lt; <span class="number">2</span>;</span><br><span class="line">  <span class="type">int</span> <span class="variable">frequency</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">  <span class="comment">//循环四次，分别获取在table数组中不同的下标位置</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> indexOf(hash, i);</span><br><span class="line">    <span class="comment">//这个操作就不多说了，其实跟上面incrementAt是一样的，定位到table[index] + 等分的位置，再根据mask取出计数值</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> (<span class="type">int</span>) ((table[index] &gt;&gt;&gt; ((start + i) &lt;&lt; <span class="number">2</span>)) &amp; <span class="number">0xfL</span>);</span><br><span class="line">    <span class="comment">//取四个中的较小值</span></span><br><span class="line">    frequency = Math.min(frequency, count);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> frequency;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>通过代码和注释或者读者可能难以理解，下图是我画出来帮助大家理解的结构图。</p>
<p>注意紫色虚线框，其中蓝色小格就是需要计算的位置：</p>
<p><img src="/images/Caffeine%E9%AB%98%E6%80%A7%E8%83%BD%E8%AE%BE%E8%AE%A1%E5%89%96%E6%9E%90__3.png" alt="upload successful"></p>
<h5 id="保新机制"><a href="#保新机制" class="headerlink" title="保新机制"></a>保新机制</h5><p>为了让缓存保持“新鲜”，剔除掉过往频率很高但之后不经常的缓存，Caffeine有一个Freshness Mechanism。做法很简答，就是当整体的统计计数（当前所有记录的频率统计之和，这个数值内部维护）达到某一个值时，那么所有记录的频率统计除以2。</p>
<p>从上面的代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//size变量就是所有记录的频率统计之，即每个记录加1，这个size都会加1</span></span><br><span class="line"><span class="comment">//sampleSize一个阈值，从FrequencySketch初始化可以看到它的值为maximumSize的10倍</span></span><br><span class="line"><span class="keyword">if</span> (added &amp;&amp; (++size == sampleSize)) &#123;</span><br><span class="line">      reset();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看到<code>reset</code>方法就是做这个事情</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/** Reduces every counter by half of its original value. */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">reset</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; table.length; i++) &#123;</span><br><span class="line">    count += Long.bitCount(table[i] &amp; ONE_MASK);</span><br><span class="line">    table[i] = (table[i] &gt;&gt;&gt; <span class="number">1</span>) &amp; RESET_MASK;</span><br><span class="line">  &#125;</span><br><span class="line">  size = (size &gt;&gt;&gt; <span class="number">1</span>) - (count &gt;&gt;&gt; <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关于这个reset方法，为什么是除以2，而不是其他，及其正确性，在最下面的参考资料的TinyLFU论文中3.3章节给出了数学证明，大家有兴趣可以看看。</p>
<h4 id="增加一个Window？"><a href="#增加一个Window？" class="headerlink" title="增加一个Window？"></a>增加一个Window？</h4><p>Caffeine通过测试发现TinyLFU在面对突发性的稀疏流量（sparse bursts）时表现很差，因为新的记录（new items）还没来得及建立足够的频率就被剔除出去了，这就使得命中率下降。</p>
<p>于是Caffeine设计出一种新的policy，即Window Tiny LFU（W-TinyLFU），并通过实验和实践发现W-TinyLFU比TinyLFU表现的更好。</p>
<p>W-TinyLFU的设计如下所示（两图等价）：</p>
<p><img src="/images/Caffeine%E9%AB%98%E6%80%A7%E8%83%BD%E8%AE%BE%E8%AE%A1%E5%89%96%E6%9E%90__4.png" alt="upload successful"></p>
<p><img src="/images/Caffeine%E9%AB%98%E6%80%A7%E8%83%BD%E8%AE%BE%E8%AE%A1%E5%89%96%E6%9E%90__5.png" alt="upload successful"></p>
<p>它主要包括两个缓存模块，主缓存是SLRU（Segmented LRU，即分段LRU），SLRU包括一个名为protected和一个名为probation的缓存区。通过增加一个缓存区（即Window Cache），当有新的记录插入时，会先在window区呆一下，就可以避免上述说的sparse bursts问题。</p>
<h4 id="淘汰策略（eviction-policy）"><a href="#淘汰策略（eviction-policy）" class="headerlink" title="淘汰策略（eviction policy）"></a>淘汰策略（eviction policy）</h4><p>当window区满了，就会根据LRU把candidate（即淘汰出来的元素）放到probation区，如果probation区也满了，就把candidate和probation将要淘汰的元素victim，两个进行“PK”，胜者留在probation，输者就要被淘汰了。</p>
<p>而且经过实验发现当window区配置为总容量的1%，剩余的99%当中的80%分给protected区，20%分给probation区时，这时整体性能和命中率表现得最好，所以Caffeine默认的比例设置就是这个。</p>
<p>不过这个比例Caffeine会在运行时根据统计数据（statistics）去动态调整，如果你的应用程序的缓存随着时间变化比较快的话，那么增加window区的比例可以提高命中率，相反缓存都是比较固定不变的话，增加Main Cache区（protected区 +probation区）的比例会有较好的效果。</p>
<p>下面我们看看上面说到的淘汰策略是怎么实现的：</p>
<p>一般缓存对读写操作后都有后续的一系列“维护”操作，Caffeine也不例外，这些操作都在<code>maintenance</code>方法，我们将要说到的淘汰策略也在里面。</p>
<p>这方法比较重要，下面也会提到，所以这里只先说跟“淘汰策略”有关的<code>evictEntries</code>和<code>climb</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Performs the pending maintenance work and sets the state flags during processing to avoid</span></span><br><span class="line"><span class="comment">   * excess scheduling attempts. The read buffer, write buffer, and reference queues are</span></span><br><span class="line"><span class="comment">   * drained, followed by expiration, and size-based eviction.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> task an additional pending task to run, or &#123;<span class="doctag">@code</span> null&#125; if not present</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@GuardedBy(&quot;evictionLock&quot;)</span></span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">maintenance</span><span class="params">(<span class="meta">@Nullable</span> Runnable task)</span> &#123;</span><br><span class="line">    lazySetDrainStatus(PROCESSING_TO_IDLE);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      drainReadBuffer();</span><br><span class="line"></span><br><span class="line">      drainWriteBuffer();</span><br><span class="line">      <span class="keyword">if</span> (task != <span class="literal">null</span>) &#123;</span><br><span class="line">        task.run();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      drainKeyReferences();</span><br><span class="line">      drainValueReferences();</span><br><span class="line"></span><br><span class="line">      expireEntries();</span><br><span class="line">      <span class="comment">//把符合条件的记录淘汰掉</span></span><br><span class="line">      evictEntries();</span><br><span class="line">      <span class="comment">//动态调整window区和protected区的大小</span></span><br><span class="line">      climb();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> ((drainStatus() != PROCESSING_TO_IDLE) || !casDrainStatus(PROCESSING_TO_IDLE, IDLE)) &#123;</span><br><span class="line">        lazySetDrainStatus(REQUIRED);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>



<p>先说一下Caffeine对上面说到的W-TinyLFU策略的实现用到的数据结构：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//最大的个数限制</span></span><br><span class="line"><span class="type">long</span> maximum;</span><br><span class="line"><span class="comment">//当前的个数</span></span><br><span class="line"><span class="type">long</span> weightedSize;</span><br><span class="line"><span class="comment">//window区的最大限制</span></span><br><span class="line"><span class="type">long</span> windowMaximum;</span><br><span class="line"><span class="comment">//window区当前的个数</span></span><br><span class="line"><span class="type">long</span> windowWeightedSize;</span><br><span class="line"><span class="comment">//protected区的最大限制</span></span><br><span class="line"><span class="type">long</span> mainProtectedMaximum;</span><br><span class="line"><span class="comment">//protected区当前的个数</span></span><br><span class="line"><span class="type">long</span> mainProtectedWeightedSize;</span><br><span class="line"><span class="comment">//下一次需要调整的大小（还需要进一步计算）</span></span><br><span class="line"><span class="type">double</span> stepSize;</span><br><span class="line"><span class="comment">//window区需要调整的大小</span></span><br><span class="line"><span class="type">long</span> adjustment;</span><br><span class="line"><span class="comment">//命中计数</span></span><br><span class="line"><span class="type">int</span> hitsInSample;</span><br><span class="line"><span class="comment">//不命中的计数</span></span><br><span class="line"><span class="type">int</span> missesInSample;</span><br><span class="line"><span class="comment">//上一次的缓存命中率</span></span><br><span class="line"><span class="type">double</span> previousSampleHitRate;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> FrequencySketch&lt;K&gt; sketch;</span><br><span class="line"><span class="comment">//window区的LRU queue（FIFO）</span></span><br><span class="line"><span class="keyword">final</span> AccessOrderDeque&lt;Node&lt;K, V&gt;&gt; accessOrderWindowDeque;</span><br><span class="line"><span class="comment">//probation区的LRU queue（FIFO）</span></span><br><span class="line"><span class="keyword">final</span> AccessOrderDeque&lt;Node&lt;K, V&gt;&gt; accessOrderProbationDeque;</span><br><span class="line"><span class="comment">//protected区的LRU queue（FIFO）</span></span><br><span class="line"><span class="keyword">final</span> AccessOrderDeque&lt;Node&lt;K, V&gt;&gt; accessOrderProtectedDeque;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>以及默认比例设置（意思看注释）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** The initial percent of the maximum weighted capacity dedicated to the main space. */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">double</span> <span class="variable">PERCENT_MAIN</span> <span class="operator">=</span> <span class="number">0.99d</span>;</span><br><span class="line"><span class="comment">/** The percent of the maximum weighted capacity dedicated to the main&#x27;s protected space. */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">double</span> <span class="variable">PERCENT_MAIN_PROTECTED</span> <span class="operator">=</span> <span class="number">0.80d</span>;</span><br><span class="line"><span class="comment">/** The difference in hit rates that restarts the climber. */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">double</span> <span class="variable">HILL_CLIMBER_RESTART_THRESHOLD</span> <span class="operator">=</span> <span class="number">0.05d</span>;</span><br><span class="line"><span class="comment">/** The percent of the total size to adapt the window by. */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">double</span> <span class="variable">HILL_CLIMBER_STEP_PERCENT</span> <span class="operator">=</span> <span class="number">0.0625d</span>;</span><br><span class="line"><span class="comment">/** The rate to decrease the step size to adapt by. */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">double</span> <span class="variable">HILL_CLIMBER_STEP_DECAY_RATE</span> <span class="operator">=</span> <span class="number">0.98d</span>;</span><br><span class="line"><span class="comment">/** The maximum number of entries that can be transfered between queues. */</span></span><br></pre></td></tr></table></figure>



<p>重点来了，evictEntries和climb方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Evicts entries if the cache exceeds the maximum. */</span></span><br><span class="line"><span class="meta">@GuardedBy(&quot;evictionLock&quot;)</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">evictEntries</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (!evicts()) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//淘汰window区的记录</span></span><br><span class="line">  <span class="type">int</span> <span class="variable">candidates</span> <span class="operator">=</span> evictFromWindow();</span><br><span class="line">  <span class="comment">//淘汰Main区的记录</span></span><br><span class="line">  evictFromMain(candidates);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Evicts entries from the window space into the main space while the window size exceeds a</span></span><br><span class="line"><span class="comment"> * maximum.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the number of candidate entries evicted from the window space</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//根据W-TinyLFU，新的数据都会无条件的加到admission window</span></span><br><span class="line"><span class="comment">//但是window是有大小限制，所以要“定期”做一下“维护”</span></span><br><span class="line"><span class="meta">@GuardedBy(&quot;evictionLock&quot;)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">evictFromWindow</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">int</span> <span class="variable">candidates</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">  <span class="comment">//查看window queue的头部节点</span></span><br><span class="line">  Node&lt;K, V&gt; node = accessOrderWindowDeque().peek();</span><br><span class="line">  <span class="comment">//如果window区超过了最大的限制，那么就要把“多出来”的记录做处理</span></span><br><span class="line">  <span class="keyword">while</span> (windowWeightedSize() &gt; windowMaximum()) &#123;</span><br><span class="line">    <span class="comment">// The pending operations will adjust the size to reflect the correct weight</span></span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//下一个节点</span></span><br><span class="line">    Node&lt;K, V&gt; next = node.getNextInAccessOrder();</span><br><span class="line">    <span class="keyword">if</span> (node.getWeight() != <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">//把node定位在probation区</span></span><br><span class="line">      node.makeMainProbation();</span><br><span class="line">      <span class="comment">//从window区去掉</span></span><br><span class="line">      accessOrderWindowDeque().remove(node);</span><br><span class="line">      <span class="comment">//加入到probation queue，相当于把节点移动到probation区（晋升了）</span></span><br><span class="line">      accessOrderProbationDeque().add(node);</span><br><span class="line">      candidates++;</span><br><span class="line">      <span class="comment">//因为移除了一个节点，所以需要调整window的size</span></span><br><span class="line">      setWindowWeightedSize(windowWeightedSize() - node.getPolicyWeight());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//处理下一个节点</span></span><br><span class="line">    node = next;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> candidates;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><code>evictFromMain</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Evicts entries from the main space if the cache exceeds the maximum capacity. The main space</span></span><br><span class="line"><span class="comment"> * determines whether admitting an entry (coming from the window space) is preferable to retaining</span></span><br><span class="line"><span class="comment"> * the eviction policy&#x27;s victim. This is decision is made using a frequency filter so that the</span></span><br><span class="line"><span class="comment"> * least frequently used entry is removed.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The window space candidates were previously placed in the MRU position and the eviction</span></span><br><span class="line"><span class="comment"> * policy&#x27;s victim is at the LRU position. The two ends of the queue are evaluated while an</span></span><br><span class="line"><span class="comment"> * eviction is required. The number of remaining candidates is provided and decremented on</span></span><br><span class="line"><span class="comment"> * eviction, so that when there are no more candidates the victim is evicted.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> candidates the number of candidate entries evicted from the window space</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//根据W-TinyLFU，从window晋升过来的要跟probation区的进行“PK”，胜者才能留下</span></span><br><span class="line"><span class="meta">@GuardedBy(&quot;evictionLock&quot;)</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">evictFromMain</span><span class="params">(<span class="type">int</span> candidates)</span> &#123;</span><br><span class="line">  <span class="type">int</span> <span class="variable">victimQueue</span> <span class="operator">=</span> PROBATION;</span><br><span class="line">  <span class="comment">//victim是probation queue的头部</span></span><br><span class="line">  Node&lt;K, V&gt; victim = accessOrderProbationDeque().peekFirst();</span><br><span class="line">  <span class="comment">//candidate是probation queue的尾部，也就是刚从window晋升来的</span></span><br><span class="line">  Node&lt;K, V&gt; candidate = accessOrderProbationDeque().peekLast();</span><br><span class="line">  <span class="comment">//当cache不够容量时才做处理</span></span><br><span class="line">  <span class="keyword">while</span> (weightedSize() &gt; maximum()) &#123;</span><br><span class="line">    <span class="comment">// Stop trying to evict candidates and always prefer the victim</span></span><br><span class="line">    <span class="keyword">if</span> (candidates == <span class="number">0</span>) &#123;</span><br><span class="line">      candidate = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对candidate为null且victim为bull的处理</span></span><br><span class="line">    <span class="keyword">if</span> ((candidate == <span class="literal">null</span>) &amp;&amp; (victim == <span class="literal">null</span>)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (victimQueue == PROBATION) &#123;</span><br><span class="line">        victim = accessOrderProtectedDeque().peekFirst();</span><br><span class="line">        victimQueue = PROTECTED;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (victimQueue == PROTECTED) &#123;</span><br><span class="line">        victim = accessOrderWindowDeque().peekFirst();</span><br><span class="line">        victimQueue = WINDOW;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// The pending operations will adjust the size to reflect the correct weight</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对节点的weight为0的处理</span></span><br><span class="line">    <span class="keyword">if</span> ((victim != <span class="literal">null</span>) &amp;&amp; (victim.getPolicyWeight() == <span class="number">0</span>)) &#123;</span><br><span class="line">      victim = victim.getNextInAccessOrder();</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((candidate != <span class="literal">null</span>) &amp;&amp; (candidate.getPolicyWeight() == <span class="number">0</span>)) &#123;</span><br><span class="line">      candidate = candidate.getPreviousInAccessOrder();</span><br><span class="line">      candidates--;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Evict immediately if only one of the entries is present</span></span><br><span class="line">    <span class="keyword">if</span> (victim == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="meta">@SuppressWarnings(&quot;NullAway&quot;)</span></span><br><span class="line">      Node&lt;K, V&gt; previous = candidate.getPreviousInAccessOrder();</span><br><span class="line">      Node&lt;K, V&gt; evict = candidate;</span><br><span class="line">      candidate = previous;</span><br><span class="line">      candidates--;</span><br><span class="line">      evictEntry(evict, RemovalCause.SIZE, <span class="number">0L</span>);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (candidate == <span class="literal">null</span>) &#123;</span><br><span class="line">      Node&lt;K, V&gt; evict = victim;</span><br><span class="line">      victim = victim.getNextInAccessOrder();</span><br><span class="line">      evictEntry(evict, RemovalCause.SIZE, <span class="number">0L</span>);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Evict immediately if an entry was collected</span></span><br><span class="line">    <span class="type">K</span> <span class="variable">victimKey</span> <span class="operator">=</span> victim.getKey();</span><br><span class="line">    <span class="type">K</span> <span class="variable">candidateKey</span> <span class="operator">=</span> candidate.getKey();</span><br><span class="line">    <span class="keyword">if</span> (victimKey == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="meta">@NonNull</span> Node&lt;K, V&gt; evict = victim;</span><br><span class="line">      victim = victim.getNextInAccessOrder();</span><br><span class="line">      evictEntry(evict, RemovalCause.COLLECTED, <span class="number">0L</span>);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (candidateKey == <span class="literal">null</span>) &#123;</span><br><span class="line">      candidates--;</span><br><span class="line">      <span class="meta">@NonNull</span> Node&lt;K, V&gt; evict = candidate;</span><br><span class="line">      candidate = candidate.getPreviousInAccessOrder();</span><br><span class="line">      evictEntry(evict, RemovalCause.COLLECTED, <span class="number">0L</span>);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//放不下的节点直接处理掉</span></span><br><span class="line">    <span class="keyword">if</span> (candidate.getPolicyWeight() &gt; maximum()) &#123;</span><br><span class="line">      candidates--;</span><br><span class="line">      Node&lt;K, V&gt; evict = candidate;</span><br><span class="line">      candidate = candidate.getPreviousInAccessOrder();</span><br><span class="line">      evictEntry(evict, RemovalCause.SIZE, <span class="number">0L</span>);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据节点的统计频率frequency来做比较，看看要处理掉victim还是candidate</span></span><br><span class="line">    <span class="comment">//admit是具体的比较规则，看下面</span></span><br><span class="line">    candidates--;</span><br><span class="line">    <span class="comment">//如果candidate胜出则淘汰victim</span></span><br><span class="line">    <span class="keyword">if</span> (admit(candidateKey, victimKey)) &#123;</span><br><span class="line">      Node&lt;K, V&gt; evict = victim;</span><br><span class="line">      victim = victim.getNextInAccessOrder();</span><br><span class="line">      evictEntry(evict, RemovalCause.SIZE, <span class="number">0L</span>);</span><br><span class="line">      candidate = candidate.getPreviousInAccessOrder();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//如果是victim胜出，则淘汰candidate</span></span><br><span class="line">      Node&lt;K, V&gt; evict = candidate;</span><br><span class="line">      candidate = candidate.getPreviousInAccessOrder();</span><br><span class="line">      evictEntry(evict, RemovalCause.SIZE, <span class="number">0L</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Determines if the candidate should be accepted into the main space, as determined by its</span></span><br><span class="line"><span class="comment"> * frequency relative to the victim. A small amount of randomness is used to protect against hash</span></span><br><span class="line"><span class="comment"> * collision attacks, where the victim&#x27;s frequency is artificially raised so that no new entries</span></span><br><span class="line"><span class="comment"> * are admitted.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> candidateKey the key for the entry being proposed for long term retention</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> victimKey the key for the entry chosen by the eviction policy for replacement</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> if the candidate should be admitted and the victim ejected</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@GuardedBy(&quot;evictionLock&quot;)</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">admit</span><span class="params">(K candidateKey, K victimKey)</span> &#123;</span><br><span class="line">  <span class="comment">//分别获取victim和candidate的统计频率</span></span><br><span class="line">  <span class="comment">//frequency这个方法的原理和实现上面已经解释了</span></span><br><span class="line">  <span class="type">int</span> <span class="variable">victimFreq</span> <span class="operator">=</span> frequencySketch().frequency(victimKey);</span><br><span class="line">  <span class="type">int</span> <span class="variable">candidateFreq</span> <span class="operator">=</span> frequencySketch().frequency(candidateKey);</span><br><span class="line">  <span class="comment">//谁大谁赢</span></span><br><span class="line">  <span class="keyword">if</span> (candidateFreq &gt; victimFreq) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果相等，candidate小于5都当输了</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (candidateFreq &lt;= <span class="number">5</span>) &#123;</span><br><span class="line">    <span class="comment">// The maximum frequency is 15 and halved to 7 after a reset to age the history. An attack</span></span><br><span class="line">    <span class="comment">// exploits that a hot candidate is rejected in favor of a hot victim. The threshold of a warm</span></span><br><span class="line">    <span class="comment">// candidate reduces the number of random acceptances to minimize the impact on the hit rate.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//如果相等且candidate大于5，则随机淘汰一个</span></span><br><span class="line">  <span class="type">int</span> <span class="variable">random</span> <span class="operator">=</span> ThreadLocalRandom.current().nextInt();</span><br><span class="line">  <span class="keyword">return</span> ((random &amp; <span class="number">127</span>) == <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><code>climb</code>方法主要是用来调整window size的，使得Caffeine可以适应你的应用类型（如OLAP或OLTP）表现出最佳的命中率。</p>
<p>下图是官方测试的数据：</p>
<p><img src="/images/Caffeine%E9%AB%98%E6%80%A7%E8%83%BD%E8%AE%BE%E8%AE%A1%E5%89%96%E6%9E%90__6.png" alt="upload successful"></p>
<p>我们看看window size的调整是怎么实现的。</p>
<p>调整时用到的默认比例数据：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//与上次命中率之差的阈值</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">double</span> <span class="variable">HILL_CLIMBER_RESTART_THRESHOLD</span> <span class="operator">=</span> <span class="number">0.05d</span>;</span><br><span class="line"><span class="comment">//步长（调整）的大小（跟最大值maximum的比例）</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">double</span> <span class="variable">HILL_CLIMBER_STEP_PERCENT</span> <span class="operator">=</span> <span class="number">0.0625d</span>;</span><br><span class="line"><span class="comment">//步长的衰减比例</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">double</span> <span class="variable">HILL_CLIMBER_STEP_DECAY_RATE</span> <span class="operator">=</span> <span class="number">0.98d</span>;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">/** Adapts the eviction policy to towards the optimal recency / frequency configuration. */</span></span><br><span class="line"><span class="comment">//climb方法的主要作用就是动态调整window区的大小（相应的，main区的大小也会发生变化，两个之和为100%）。</span></span><br><span class="line"><span class="comment">//因为区域的大小发生了变化，那么区域内的数据也可能需要发生相应的移动。</span></span><br><span class="line"><span class="meta">@GuardedBy(&quot;evictionLock&quot;)</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">climb</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (!evicts()) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//确定window需要调整的大小</span></span><br><span class="line">  determineAdjustment();</span><br><span class="line">  <span class="comment">//如果protected区有溢出，把溢出部分移动到probation区。因为下面的操作有可能需要调整到protected区。</span></span><br><span class="line">  demoteFromMainProtected();</span><br><span class="line">  <span class="type">long</span> <span class="variable">amount</span> <span class="operator">=</span> adjustment();</span><br><span class="line">  <span class="keyword">if</span> (amount == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (amount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">//增加window的大小</span></span><br><span class="line">    increaseWindow();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//减少window的大小</span></span><br><span class="line">    decreaseWindow();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>下面分别展开每个方法来解释：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Calculates the amount to adapt the window by and sets &#123;<span class="doctag">@link</span> #adjustment()&#125; accordingly. */</span></span><br><span class="line"><span class="meta">@GuardedBy(&quot;evictionLock&quot;)</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">determineAdjustment</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="comment">//如果frequencySketch还没初始化，则返回</span></span><br><span class="line">  <span class="keyword">if</span> (frequencySketch().isNotInitialized()) &#123;</span><br><span class="line">    setPreviousSampleHitRate(<span class="number">0.0</span>);</span><br><span class="line">    setMissesInSample(<span class="number">0</span>);</span><br><span class="line">    setHitsInSample(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//总请求量 = 命中 + miss</span></span><br><span class="line">  <span class="type">int</span> <span class="variable">requestCount</span> <span class="operator">=</span> hitsInSample() + missesInSample();</span><br><span class="line">  <span class="comment">//没达到sampleSize则返回</span></span><br><span class="line">  <span class="comment">//默认下sampleSize = 10 * maximum。用sampleSize来判断缓存是否足够”热“。</span></span><br><span class="line">  <span class="keyword">if</span> (requestCount &lt; frequencySketch().sampleSize) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//命中率的公式 = 命中 / 总请求</span></span><br><span class="line">  <span class="type">double</span> <span class="variable">hitRate</span> <span class="operator">=</span> (<span class="type">double</span>) hitsInSample() / requestCount;</span><br><span class="line">  <span class="comment">//命中率的差值</span></span><br><span class="line">  <span class="type">double</span> <span class="variable">hitRateChange</span> <span class="operator">=</span> hitRate - previousSampleHitRate();</span><br><span class="line">  <span class="comment">//本次调整的大小，是由命中率的差值和上次的stepSize决定的</span></span><br><span class="line">  <span class="type">double</span> <span class="variable">amount</span> <span class="operator">=</span> (hitRateChange &gt;= <span class="number">0</span>) ? stepSize() : -stepSize();</span><br><span class="line">  <span class="comment">//下次的调整大小：如果命中率的之差大于0.05，则重置为0.065 * maximum，否则按照0.98来进行衰减</span></span><br><span class="line">  <span class="type">double</span> <span class="variable">nextStepSize</span> <span class="operator">=</span> (Math.abs(hitRateChange) &gt;= HILL_CLIMBER_RESTART_THRESHOLD)</span><br><span class="line">      ? HILL_CLIMBER_STEP_PERCENT * maximum() * (amount &gt;= <span class="number">0</span> ? <span class="number">1</span> : -<span class="number">1</span>)</span><br><span class="line">      : HILL_CLIMBER_STEP_DECAY_RATE * amount;</span><br><span class="line">  setPreviousSampleHitRate(hitRate);</span><br><span class="line">  setAdjustment((<span class="type">long</span>) amount);</span><br><span class="line">  setStepSize(nextStepSize);</span><br><span class="line">  setMissesInSample(<span class="number">0</span>);</span><br><span class="line">  setHitsInSample(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Transfers the nodes from the protected to the probation region if it exceeds the maximum. */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//这个方法比较简单，减少protected区溢出的部分</span></span><br><span class="line"><span class="meta">@GuardedBy(&quot;evictionLock&quot;)</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">demoteFromMainProtected</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">long</span> <span class="variable">mainProtectedMaximum</span> <span class="operator">=</span> mainProtectedMaximum();</span><br><span class="line">  <span class="type">long</span> <span class="variable">mainProtectedWeightedSize</span> <span class="operator">=</span> mainProtectedWeightedSize();</span><br><span class="line">  <span class="keyword">if</span> (mainProtectedWeightedSize &lt;= mainProtectedMaximum) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; QUEUE_TRANSFER_THRESHOLD; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (mainProtectedWeightedSize &lt;= mainProtectedMaximum) &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node&lt;K, V&gt; demoted = accessOrderProtectedDeque().poll();</span><br><span class="line">    <span class="keyword">if</span> (demoted == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    demoted.makeMainProbation();</span><br><span class="line">    accessOrderProbationDeque().add(demoted);</span><br><span class="line">    mainProtectedWeightedSize -= demoted.getPolicyWeight();</span><br><span class="line">  &#125;</span><br><span class="line">  setMainProtectedWeightedSize(mainProtectedWeightedSize);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Increases the size of the admission window by shrinking the portion allocated to the main</span></span><br><span class="line"><span class="comment"> * space. As the main space is partitioned into probation and protected regions (80% / 20%), for</span></span><br><span class="line"><span class="comment"> * simplicity only the protected is reduced. If the regions exceed their maximums, this may cause</span></span><br><span class="line"><span class="comment"> * protected items to be demoted to the probation region and probation items to be demoted to the</span></span><br><span class="line"><span class="comment"> * admission window.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//增加window区的大小，这个方法比较简单，思路就像我上面说的</span></span><br><span class="line"><span class="meta">@GuardedBy(&quot;evictionLock&quot;)</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">increaseWindow</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (mainProtectedMaximum() == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">long</span> <span class="variable">quota</span> <span class="operator">=</span> Math.min(adjustment(), mainProtectedMaximum());</span><br><span class="line">  setMainProtectedMaximum(mainProtectedMaximum() - quota);</span><br><span class="line">  setWindowMaximum(windowMaximum() + quota);</span><br><span class="line">  demoteFromMainProtected();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; QUEUE_TRANSFER_THRESHOLD; i++) &#123;</span><br><span class="line">    Node&lt;K, V&gt; candidate = accessOrderProbationDeque().peek();</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">probation</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> ((candidate == <span class="literal">null</span>) || (quota &lt; candidate.getPolicyWeight())) &#123;</span><br><span class="line">      candidate = accessOrderProtectedDeque().peek();</span><br><span class="line">      probation = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (candidate == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">weight</span> <span class="operator">=</span> candidate.getPolicyWeight();</span><br><span class="line">    <span class="keyword">if</span> (quota &lt; weight) &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    quota -= weight;</span><br><span class="line">    <span class="keyword">if</span> (probation) &#123;</span><br><span class="line">      accessOrderProbationDeque().remove(candidate);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      setMainProtectedWeightedSize(mainProtectedWeightedSize() - weight);</span><br><span class="line">      accessOrderProtectedDeque().remove(candidate);</span><br><span class="line">    &#125;</span><br><span class="line">    setWindowWeightedSize(windowWeightedSize() + weight);</span><br><span class="line">    accessOrderWindowDeque().add(candidate);</span><br><span class="line">    candidate.makeWindow();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  setMainProtectedMaximum(mainProtectedMaximum() + quota);</span><br><span class="line">  setWindowMaximum(windowMaximum() - quota);</span><br><span class="line">  setAdjustment(quota);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Decreases the size of the admission window and increases the main&#x27;s protected region. */</span></span><br><span class="line"><span class="comment">//同上increaseWindow差不多，反操作</span></span><br><span class="line"><span class="meta">@GuardedBy(&quot;evictionLock&quot;)</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">decreaseWindow</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (windowMaximum() &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">long</span> <span class="variable">quota</span> <span class="operator">=</span> Math.min(-adjustment(), Math.max(<span class="number">0</span>, windowMaximum() - <span class="number">1</span>));</span><br><span class="line">  setMainProtectedMaximum(mainProtectedMaximum() + quota);</span><br><span class="line">  setWindowMaximum(windowMaximum() - quota);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; QUEUE_TRANSFER_THRESHOLD; i++) &#123;</span><br><span class="line">    Node&lt;K, V&gt; candidate = accessOrderWindowDeque().peek();</span><br><span class="line">    <span class="keyword">if</span> (candidate == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">weight</span> <span class="operator">=</span> candidate.getPolicyWeight();</span><br><span class="line">    <span class="keyword">if</span> (quota &lt; weight) &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    quota -= weight;</span><br><span class="line">    setMainProtectedWeightedSize(mainProtectedWeightedSize() + weight);</span><br><span class="line">    setWindowWeightedSize(windowWeightedSize() - weight);</span><br><span class="line">    accessOrderWindowDeque().remove(candidate);</span><br><span class="line">    accessOrderProbationDeque().add(candidate);</span><br><span class="line">    candidate.makeMainProbation();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  setMainProtectedMaximum(mainProtectedMaximum() - quota);</span><br><span class="line">  setWindowMaximum(windowMaximum() + quota);</span><br><span class="line">  setAdjustment(-quota);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>以上，是Caffeine的W-TinyLFU策略的设计原理及代码实现解析。</p>
<h3 id="异步的高性能读写"><a href="#异步的高性能读写" class="headerlink" title="异步的高性能读写"></a>异步的高性能读写</h3><p>一般的缓存每次对数据处理完之后（读的话，已经存在则直接返回，不存在则load数据，保存，再返回；写的话，则直接插入或更新），但是因为要维护一些淘汰策略，则需要一些额外的操作，诸如：</p>
<ul>
<li>计算和比较数据的是否过期</li>
<li>统计频率（像LFU或其变种）</li>
<li>维护read queue和write queue</li>
<li>淘汰符合条件的数据</li>
<li>等等。。。</li>
</ul>
<p>这种数据的读写伴随着缓存状态的变更，Guava Cache的做法是把这些操作和读写操作放在一起，在一个同步加锁的操作中完成，虽然Guava Cache巧妙地利用了JDK的ConcurrentHashMap（分段锁或者无锁CAS）来降低锁的密度，达到提高并发度的目的。但是，对于一些热点数据，这种做法还是避免不了频繁的锁竞争。Caffeine借鉴了数据库系统的WAL（Write-Ahead Logging）思想，即先写日志再执行操作，这种思想同样适合缓存的，执行读写操作时，先把操作记录在缓冲区，然后在合适的时机异步、批量地执行缓冲区中的内容。但在执行缓冲区的内容时，也是需要在缓冲区加上同步锁的，不然存在并发问题，只不过这样就可以把对锁的竞争从缓存数据转移到对缓冲区上。</p>
<h4 id="ReadBuffer"><a href="#ReadBuffer" class="headerlink" title="ReadBuffer"></a>ReadBuffer</h4><p>在Caffeine的内部实现中，为了很好的支持不同的Features（如Eviction，Removal，Refresh，Statistics，Cleanup，Policy等等），扩展了很多子类，它们共同的父类是<code>BoundedLocalCache</code>，而<code>readBuffer</code>就是作为它们共有的属性，即都是用一样的readBuffer，看定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Buffer&lt;Node&lt;K, V&gt;&gt; readBuffer;</span><br><span class="line"></span><br><span class="line">readBuffer = evicts() || collectKeys() || collectValues() || expiresAfterAccess()</span><br><span class="line">        ? <span class="keyword">new</span> <span class="title class_">BoundedBuffer</span>&lt;&gt;()</span><br><span class="line">        : Buffer.disabled();</span><br></pre></td></tr></table></figure>



<p>上面提到Caffeine对每次缓存的读操作都会触发<code>afterRead</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Performs the post-processing work required after a read.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> node the entry in the page replacement policy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> now the current time, in nanoseconds</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> recordHit if the hit count should be incremented</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">afterRead</span><span class="params">(Node&lt;K, V&gt; node, <span class="type">long</span> now, <span class="type">boolean</span> recordHit)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (recordHit) &#123;</span><br><span class="line">    statsCounter().recordHits(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//把记录加入到readBuffer</span></span><br><span class="line">  <span class="comment">//判断是否需要立即处理readBuffer</span></span><br><span class="line">  <span class="comment">//注意这里无论offer是否成功都可以走下去的，即允许写入readBuffer丢失，因为这个</span></span><br><span class="line">  <span class="type">boolean</span> <span class="variable">delayable</span> <span class="operator">=</span> skipReadBuffer() || (readBuffer.offer(node) != Buffer.FULL);</span><br><span class="line">  <span class="keyword">if</span> (shouldDrainBuffers(delayable)) &#123;</span><br><span class="line">    scheduleDrainBuffers();</span><br><span class="line">  &#125;</span><br><span class="line">  refreshIfNeeded(node, now);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Returns whether maintenance work is needed.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> delayable if draining the read buffer can be delayed</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//caffeine用了一组状态来定义和管理“维护”的过程</span></span><br><span class="line">  <span class="type">boolean</span> <span class="title function_">shouldDrainBuffers</span><span class="params">(<span class="type">boolean</span> delayable)</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> (drainStatus()) &#123;</span><br><span class="line">      <span class="keyword">case</span> IDLE:</span><br><span class="line">        <span class="keyword">return</span> !delayable;</span><br><span class="line">      <span class="keyword">case</span> REQUIRED:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      <span class="keyword">case</span> PROCESSING_TO_IDLE:</span><br><span class="line">      <span class="keyword">case</span> PROCESSING_TO_REQUIRED:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>



<p>重点看<code>BoundedBuffer</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A striped, non-blocking, bounded buffer.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> ben.manes@gmail.com (Ben Manes)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;E&gt; the type of elements maintained by this buffer</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">BoundedBuffer</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">StripedBuffer</span>&lt;E&gt;</span><br></pre></td></tr></table></figure>

<p>它是一个striped、非阻塞、有界限的buffer，继承于<code>StripedBuffer</code>类。下面看看StripedBuffer的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A base class providing the mechanics for supporting dynamic striping of bounded buffers. This</span></span><br><span class="line"><span class="comment"> * implementation is an adaption of the numeric 64-bit &#123;<span class="doctag">@link</span> java.util.concurrent.atomic.Striped64&#125;</span></span><br><span class="line"><span class="comment"> * class, which is used by atomic counters. The approach was modified to lazily grow an array of</span></span><br><span class="line"><span class="comment"> * buffers in order to minimize memory usage for caches that are not heavily contended on.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> dl@cs.oswego.edu (Doug Lea)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> ben.manes@gmail.com (Ben Manes)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">StripedBuffer</span>&lt;E&gt; <span class="keyword">implements</span> <span class="title class_">Buffer</span>&lt;E&gt;</span><br></pre></td></tr></table></figure>

<p>这个StripedBuffer设计的思想是跟<code>Striped64</code>类似的，通过扩展结构把竞争热点分离。</p>
<p>具体实现是这样的，StripedBuffer维护一个Buffer[]数组，每个元素就是一个<code>RingBuffer</code>，每个线程用自己<code>threadLocalRandomProbe</code>属性作为hash值，这样就相当于每个线程都有自己“专属”的RingBuffer，就不会产生竞争啦，而不是用key的hashCode作为hash值，因为会产生热点数据问题。</p>
<p>看看StripedBuffer的属性</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/** Table of buffers. When non-null, size is a power of 2. */</span></span><br><span class="line"><span class="comment">//RingBuffer数组</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> Buffer&lt;E&gt; <span class="meta">@Nullable</span>[] table;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当进行resize时，需要整个table锁住。tableBusy作为CAS的标记。</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">TABLE_BUSY</span> <span class="operator">=</span> UnsafeAccess.objectFieldOffset(StripedBuffer.class, <span class="string">&quot;tableBusy&quot;</span>);</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">PROBE</span> <span class="operator">=</span> UnsafeAccess.objectFieldOffset(Thread.class, <span class="string">&quot;threadLocalRandomProbe&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Number of CPUS. */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">NCPU</span> <span class="operator">=</span> Runtime.getRuntime().availableProcessors();</span><br><span class="line"></span><br><span class="line"><span class="comment">/** The bound on the table size. */</span></span><br><span class="line"><span class="comment">//table最大size</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAXIMUM_TABLE_SIZE</span> <span class="operator">=</span> <span class="number">4</span> * ceilingNextPowerOfTwo(NCPU);</span><br><span class="line"></span><br><span class="line"><span class="comment">/** The maximum number of attempts when trying to expand the table. */</span></span><br><span class="line"><span class="comment">//如果发生竞争时（CAS失败）的尝试次数</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">ATTEMPTS</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Table of buffers. When non-null, size is a power of 2. */</span></span><br><span class="line"><span class="comment">//核心数据结构</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> Buffer&lt;E&gt; <span class="meta">@Nullable</span>[] table;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Spinlock (locked via CAS) used when resizing and/or creating Buffers. */</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="type">int</span> tableBusy;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** CASes the tableBusy field from 0 to 1 to acquire lock. */</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">casTableBusy</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> UnsafeAccess.UNSAFE.compareAndSwapInt(<span class="built_in">this</span>, TABLE_BUSY, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns the probe value for the current thread. Duplicated from ThreadLocalRandom because of</span></span><br><span class="line"><span class="comment"> * packaging restrictions.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getProbe</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> UnsafeAccess.UNSAFE.getInt(Thread.currentThread(), PROBE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><code>offer</code>方法，当没初始化或存在竞争时，则扩容为2倍。</p>
<p>实际是调用<code>RingBuffer</code>的offer方法，把数据追加到RingBuffer后面。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">offer</span><span class="params">(E e)</span> &#123;</span><br><span class="line">  <span class="type">int</span> mask;</span><br><span class="line">  <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">  Buffer&lt;E&gt; buffer;</span><br><span class="line">  <span class="comment">//是否不存在竞争</span></span><br><span class="line">  <span class="type">boolean</span> <span class="variable">uncontended</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">  Buffer&lt;E&gt;[] buffers = table</span><br><span class="line">  <span class="comment">//是否已经初始化</span></span><br><span class="line">  <span class="keyword">if</span> ((buffers == <span class="literal">null</span>)</span><br><span class="line">      || (mask = buffers.length - <span class="number">1</span>) &lt; <span class="number">0</span></span><br><span class="line">      <span class="comment">//用thread的随机值作为hash值，得到对应位置的RingBuffer</span></span><br><span class="line">      || (buffer = buffers[getProbe() &amp; mask]) == <span class="literal">null</span></span><br><span class="line">      <span class="comment">//检查追加到RingBuffer是否成功</span></span><br><span class="line">      || !(uncontended = ((result = buffer.offer(e)) != Buffer.FAILED))) &#123;</span><br><span class="line">    <span class="comment">//其中一个符合条件则进行扩容</span></span><br><span class="line">    expandOrRetry(e, uncontended);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Handles cases of updates involving initialization, resizing, creating new Buffers, and/or</span></span><br><span class="line"><span class="comment"> * contention. See above for explanation. This method suffers the usual non-modularity problems of</span></span><br><span class="line"><span class="comment"> * optimistic retry code, relying on rechecked sets of reads.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e the element to add</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> wasUncontended false if CAS failed before call</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//这个方法比较长，但思路还是相对清晰的。</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;PMD.ConfusingTernary&quot;)</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">expandOrRetry</span><span class="params">(E e, <span class="type">boolean</span> wasUncontended)</span> &#123;</span><br><span class="line">  <span class="type">int</span> h;</span><br><span class="line">  <span class="keyword">if</span> ((h = getProbe()) == <span class="number">0</span>) &#123;</span><br><span class="line">    ThreadLocalRandom.current(); <span class="comment">// force initialization</span></span><br><span class="line">    h = getProbe();</span><br><span class="line">    wasUncontended = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">boolean</span> <span class="variable">collide</span> <span class="operator">=</span> <span class="literal">false</span>; <span class="comment">// True if last slot nonempty</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">attempt</span> <span class="operator">=</span> <span class="number">0</span>; attempt &lt; ATTEMPTS; attempt++) &#123;</span><br><span class="line">    Buffer&lt;E&gt;[] buffers;</span><br><span class="line">    Buffer&lt;E&gt; buffer;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">if</span> (((buffers = table) != <span class="literal">null</span>) &amp;&amp; ((n = buffers.length) &gt; <span class="number">0</span>)) &#123;</span><br><span class="line">      <span class="keyword">if</span> ((buffer = buffers[(n - <span class="number">1</span>) &amp; h]) == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((tableBusy == <span class="number">0</span>) &amp;&amp; casTableBusy()) &#123; <span class="comment">// Try to attach new Buffer</span></span><br><span class="line">          <span class="type">boolean</span> <span class="variable">created</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">          <span class="keyword">try</span> &#123; <span class="comment">// Recheck under lock</span></span><br><span class="line">            Buffer&lt;E&gt;[] rs;</span><br><span class="line">            <span class="type">int</span> mask, j;</span><br><span class="line">            <span class="keyword">if</span> (((rs = table) != <span class="literal">null</span>) &amp;&amp; ((mask = rs.length) &gt; <span class="number">0</span>)</span><br><span class="line">                &amp;&amp; (rs[j = (mask - <span class="number">1</span>) &amp; h] == <span class="literal">null</span>)) &#123;</span><br><span class="line">              rs[j] = create(e);</span><br><span class="line">              created = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            tableBusy = <span class="number">0</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (created) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">continue</span>; <span class="comment">// Slot is now non-empty</span></span><br><span class="line">        &#125;</span><br><span class="line">        collide = <span class="literal">false</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!wasUncontended) &#123; <span class="comment">// CAS already known to fail</span></span><br><span class="line">        wasUncontended = <span class="literal">true</span>;      <span class="comment">// Continue after rehash</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (buffer.offer(e) != Buffer.FAILED) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (n &gt;= MAXIMUM_TABLE_SIZE || table != buffers) &#123;</span><br><span class="line">        collide = <span class="literal">false</span>; <span class="comment">// At max size or stale</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!collide) &#123;</span><br><span class="line">        collide = <span class="literal">true</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tableBusy == <span class="number">0</span> &amp;&amp; casTableBusy()) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (table == buffers) &#123; <span class="comment">// Expand table unless stale</span></span><br><span class="line">            table = Arrays.copyOf(buffers, n &lt;&lt; <span class="number">1</span>);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          tableBusy = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        collide = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">continue</span>; <span class="comment">// Retry with expanded table</span></span><br><span class="line">      &#125;</span><br><span class="line">      h = advanceProbe(h);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((tableBusy == <span class="number">0</span>) &amp;&amp; (table == buffers) &amp;&amp; casTableBusy()) &#123;</span><br><span class="line">      <span class="type">boolean</span> <span class="variable">init</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">      <span class="keyword">try</span> &#123; <span class="comment">// Initialize table</span></span><br><span class="line">        <span class="keyword">if</span> (table == buffers) &#123;</span><br><span class="line">          <span class="meta">@SuppressWarnings(&#123;&quot;unchecked&quot;, &quot;rawtypes&quot;&#125;)</span></span><br><span class="line">          Buffer&lt;E&gt;[] rs = <span class="keyword">new</span> <span class="title class_">Buffer</span>[<span class="number">1</span>];</span><br><span class="line">          rs[<span class="number">0</span>] = create(e);</span><br><span class="line">          table = rs;</span><br><span class="line">          init = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        tableBusy = <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (init) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>最后看看<code>RingBuffer</code>，注意RingBuffer是<code>BoundedBuffer</code>的内部类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line"><span class="comment">/** The maximum number of elements per buffer. */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">BUFFER_SIZE</span> <span class="operator">=</span> <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Assume 4-byte references and 64-byte cache line (16 elements per line)</span></span><br><span class="line"><span class="comment">//256长度，但是是以16为单位，所以最多存放16个元素</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SPACED_SIZE</span> <span class="operator">=</span> BUFFER_SIZE &lt;&lt; <span class="number">4</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SPACED_MASK</span> <span class="operator">=</span> SPACED_SIZE - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">OFFSET</span> <span class="operator">=</span> <span class="number">16</span>;	</span><br><span class="line"><span class="comment">//RingBuffer数组</span></span><br><span class="line"><span class="keyword">final</span> AtomicReferenceArray&lt;E&gt; buffer;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//插入方法</span></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">offer</span><span class="params">(E e)</span> &#123;</span><br><span class="line">   <span class="type">long</span> <span class="variable">head</span> <span class="operator">=</span> readCounter;</span><br><span class="line">   <span class="type">long</span> <span class="variable">tail</span> <span class="operator">=</span> relaxedWriteCounter();</span><br><span class="line">   <span class="comment">//用head和tail来限制个数</span></span><br><span class="line">   <span class="type">long</span> <span class="variable">size</span> <span class="operator">=</span> (tail - head);</span><br><span class="line">   <span class="keyword">if</span> (size &gt;= SPACED_SIZE) &#123;</span><br><span class="line">     <span class="keyword">return</span> Buffer.FULL;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//tail追加16</span></span><br><span class="line">   <span class="keyword">if</span> (casWriteCounter(tail, tail + OFFSET)) &#123;</span><br><span class="line">     <span class="comment">//用tail“取余”得到下标</span></span><br><span class="line">     <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> (<span class="type">int</span>) (tail &amp; SPACED_MASK);</span><br><span class="line">     <span class="comment">//用unsafe.putOrderedObject设值</span></span><br><span class="line">     buffer.lazySet(index, e);</span><br><span class="line">     <span class="keyword">return</span> Buffer.SUCCESS;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//如果CAS失败则返回失败</span></span><br><span class="line">   <span class="keyword">return</span> Buffer.FAILED;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//用consumer来处理buffer的数据</span></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drainTo</span><span class="params">(Consumer&lt;E&gt; consumer)</span> &#123;</span><br><span class="line">   <span class="type">long</span> <span class="variable">head</span> <span class="operator">=</span> readCounter;</span><br><span class="line">   <span class="type">long</span> <span class="variable">tail</span> <span class="operator">=</span> relaxedWriteCounter();</span><br><span class="line">   <span class="comment">//判断数据多少</span></span><br><span class="line">   <span class="type">long</span> <span class="variable">size</span> <span class="operator">=</span> (tail - head);</span><br><span class="line">   <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line">     <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">do</span> &#123;</span><br><span class="line">     <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> (<span class="type">int</span>) (head &amp; SPACED_MASK);</span><br><span class="line">     <span class="type">E</span> <span class="variable">e</span> <span class="operator">=</span> buffer.get(index);</span><br><span class="line">     <span class="keyword">if</span> (e == <span class="literal">null</span>) &#123;</span><br><span class="line">       <span class="comment">// not published yet</span></span><br><span class="line">       <span class="keyword">break</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     buffer.lazySet(index, <span class="literal">null</span>);</span><br><span class="line">     consumer.accept(e);</span><br><span class="line">     <span class="comment">//head也跟tail一样，每次递增16</span></span><br><span class="line">     head += OFFSET;</span><br><span class="line">   &#125; <span class="keyword">while</span> (head != tail);</span><br><span class="line">   lazySetReadCounter(head);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>注意，ring buffer的size（固定是16个）是不变的，变的是head和tail而已。</p>
<p>总的来说ReadBuffer有如下特点：</p>
<ul>
<li>使用 Striped-RingBuffer来提升对buffer的读写</li>
<li>用thread的hash来避开热点key的竞争</li>
<li>允许写入的丢失</li>
</ul>
<h4 id="WriteBuffer"><a href="#WriteBuffer" class="headerlink" title="WriteBuffer"></a>WriteBuffer</h4><p>writeBuffer跟readBuffer不一样，主要体现在使用场景的不一样。本来缓存的一般场景是读多写少的，读的并发会更高，且afterRead显得没那么重要，允许延迟甚至丢失。写不一样，写afterWrite不允许丢失，且要求尽量马上执行。Caffeine使用MPSC（Multiple Producer / Single Consumer）作为buffer数组，实现在<code>MpscGrowableArrayQueue</code>类，它是仿照JCTools的MpscGrowableArrayQueue来写的。</p>
<p>MPSC允许无锁的高并发写入，但只允许一个消费者，同时也牺牲了部分操作。</p>
<p>MPSC我打算另外分析，这里不展开了。</p>
<h3 id="TimerWheel"><a href="#TimerWheel" class="headerlink" title="TimerWheel"></a>TimerWheel</h3><p>除了支持<code>expireAfterAccess</code>和<code>expireAfterWrite</code>之外（Guava Cache也支持这两个特性），Caffeine还支持<code>expireAfter</code>。因为expireAfterAccess和expireAfterWrite都只能是固定的过期时间，这可能满足不了某些场景，譬如记录的过期时间是需要根据某些条件而不一样的，这就需要用户自定义过期时间。</p>
<p>先看看expireAfter的用法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> LoadingCache&lt;String, String&gt; cache = Caffeine.newBuilder()</span><br><span class="line">        .maximumSize(<span class="number">256L</span>)</span><br><span class="line">        .initialCapacity(<span class="number">1</span>)</span><br><span class="line">        <span class="comment">//.expireAfterAccess(2, TimeUnit.DAYS)</span></span><br><span class="line">        <span class="comment">//.expireAfterWrite(2, TimeUnit.HOURS)</span></span><br><span class="line">        .refreshAfterWrite(<span class="number">1</span>, TimeUnit.HOURS)</span><br><span class="line">        <span class="comment">//自定义过期时间</span></span><br><span class="line">        .expireAfter(<span class="keyword">new</span> <span class="title class_">Expiry</span>&lt;String, String&gt;() &#123;</span><br><span class="line">            <span class="comment">//返回创建后的过期时间</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">expireAfterCreate</span><span class="params">(<span class="meta">@NonNull</span> String key, <span class="meta">@NonNull</span> String value, <span class="type">long</span> currentTime)</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//返回更新后的过期时间</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">expireAfterUpdate</span><span class="params">(<span class="meta">@NonNull</span> String key, <span class="meta">@NonNull</span> String value, <span class="type">long</span> currentTime, <span class="meta">@NonNegative</span> <span class="type">long</span> currentDuration)</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//返回读取后的过期时间</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">expireAfterRead</span><span class="params">(<span class="meta">@NonNull</span> String key, <span class="meta">@NonNull</span> String value, <span class="type">long</span> currentTime, <span class="meta">@NonNegative</span> <span class="type">long</span> currentDuration)</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        .recordStats()</span><br><span class="line">        .build(<span class="keyword">new</span> <span class="title class_">CacheLoader</span>&lt;String, String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Nullable</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> String <span class="title function_">load</span><span class="params">(<span class="meta">@NonNull</span> String key)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;value_&quot;</span> + key;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure>

<p>通过自定义过期时间，使得不同的key可以动态的得到不同的过期时间。</p>
<p>注意，我把expireAfterAccess和expireAfterWrite注释了，因为这两个特性不能跟expireAfter一起使用。</p>
<p>而当使用了expireAfter特性后，Caffeine会启用一种叫“时间轮”的算法来实现这个功能。更多关于时间轮的介绍，可以看我的文章<a href="/2019/03/28/HashedWheelTimer%E6%97%B6%E9%97%B4%E8%BD%AE%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/" title="HashedWheelTimer时间轮原理分析">HashedWheelTimer时间轮原理分析</a>。</p>
<p>好，重点来了，为什么要用时间轮？</p>
<p>对expireAfterAccess和expireAfterWrite的实现是用一个<code>AccessOrderDeque</code>双端队列，它是FIFO的，因为它们的过期时间是固定的，所以在队列头的数据肯定是最早过期的，要处理过期数据时，只需要首先看看头部是否过期，然后再挨个检查就可以了。但是，如果过期时间不一样的话，这需要对accessOrderQueue进行排序&amp;插入，这个代价太大了。于是，Caffeine用了一种更加高效、优雅的算法-时间轮。</p>
<p>时间轮的结构：</p>
<p><img src="/images/Caffeine%E9%AB%98%E6%80%A7%E8%83%BD%E8%AE%BE%E8%AE%A1%E5%89%96%E6%9E%90__7.png" alt="upload successful"></p>
<p>因为在我的对时间轮分析的文章里已经说了时间轮的原理和机制了，所以我就不展开Caffeine对时间轮的实现了。</p>
<p>Caffeine对时间轮的实现在<code>TimerWheel</code>，它是一种多层时间轮（hierarchical timing wheels ）。</p>
<p>看看元素加入到时间轮的<code>schedule</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Schedules a timer event for the node.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> node the entry in the cache</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">schedule</span><span class="params">(<span class="meta">@NonNull</span> Node&lt;K, V&gt; node)</span> &#123;</span><br><span class="line">  Node&lt;K, V&gt; sentinel = findBucket(node.getVariableTime());</span><br><span class="line">  link(sentinel, node);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Determines the bucket that the timer event should be added to.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> time the time when the event fires</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the sentinel at the head of the bucket</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Node&lt;K, V&gt; <span class="title function_">findBucket</span><span class="params">(<span class="type">long</span> time)</span> &#123;</span><br><span class="line">  <span class="type">long</span> <span class="variable">duration</span> <span class="operator">=</span> time - nanos;</span><br><span class="line">  <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> wheel.length - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (duration &lt; SPANS[i + <span class="number">1</span>]) &#123;</span><br><span class="line">      <span class="type">long</span> <span class="variable">ticks</span> <span class="operator">=</span> (time &gt;&gt;&gt; SHIFT[i]);</span><br><span class="line">      <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> (<span class="type">int</span>) (ticks &amp; (wheel[i].length - <span class="number">1</span>));</span><br><span class="line">      <span class="keyword">return</span> wheel[i][index];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> wheel[length][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Adds the entry at the tail of the bucket&#x27;s list. */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">link</span><span class="params">(Node&lt;K, V&gt; sentinel, Node&lt;K, V&gt; node)</span> &#123;</span><br><span class="line">  node.setPreviousInVariableOrder(sentinel.getPreviousInVariableOrder());</span><br><span class="line">  node.setNextInVariableOrder(sentinel);</span><br><span class="line"></span><br><span class="line">  sentinel.getPreviousInVariableOrder().setNextInVariableOrder(node);</span><br><span class="line">  sentinel.setPreviousInVariableOrder(node);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>###其他</p>
<p>Caffeine还有其他的优化性能的手段，如使用软引用和弱引用、消除伪共享、CompletableFuture异步等等。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Caffeien是一个优秀的本地缓存，通过使用W-TinyLFU算法， 高性能的readBuffer和WriteBuffer，时间轮算法等，使得它拥有高性能，高命中率（near optimal），低内存占用等特点。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a target="_blank" rel="noopener" href="https://arxiv.org/abs/1512.00727">TinyLFU论文</a></p>
<p><a target="_blank" rel="noopener" href="http://highscalability.com/blog/2016/1/25/design-of-a-modern-cache.html">Design Of A Modern Cache</a></p>
<p><a target="_blank" rel="noopener" href="http://highscalability.com/blog/2019/2/25/design-of-a-modern-cachepart-deux.html">Design Of A Modern Cache—Part Deux</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/ben-manes/caffeine">Caffeine的github</a></p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/java/" rel="tag"># java</a>
              <a href="/tags/cache/" rel="tag"># cache</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/posts/6518ba8/" rel="prev" title="Striped64和LongAdder">
      <i class="fa fa-chevron-left"></i> Striped64和LongAdder
    </a></div>
      <div class="post-nav-item">
    <a href="/posts/f00ab7dc/" rel="next" title="MpscGrowableArrayQueue分析">
      MpscGrowableArrayQueue分析 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A6%82%E8%A6%81"><span class="nav-number">1.</span> <span class="nav-text">概要</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%8EGuava-Cache%E6%AF%94%E8%BE%83"><span class="nav-number">2.</span> <span class="nav-text">与Guava Cache比较</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8Caffeine"><span class="nav-number">3.</span> <span class="nav-text">使用Caffeine</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Caffeine%E7%9A%84%E9%AB%98%E6%80%A7%E8%83%BD%E8%AE%BE%E8%AE%A1"><span class="nav-number">4.</span> <span class="nav-text">Caffeine的高性能设计</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#W-TinyLFU%E6%95%B4%E4%BD%93%E8%AE%BE%E8%AE%A1"><span class="nav-number">4.1.</span> <span class="nav-text">W-TinyLFU整体设计</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#LRU%E5%92%8CLFU%E7%9A%84%E7%BC%BA%E7%82%B9"><span class="nav-number">4.1.1.</span> <span class="nav-text">LRU和LFU的缺点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#TinyLFU"><span class="nav-number">4.1.2.</span> <span class="nav-text">TinyLFU</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BB%9F%E8%AE%A1%E9%A2%91%E7%8E%87Count%E2%80%93Min-Sketch%E7%AE%97%E6%B3%95"><span class="nav-number">4.1.2.1.</span> <span class="nav-text">统计频率Count–Min Sketch算法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BF%9D%E6%96%B0%E6%9C%BA%E5%88%B6"><span class="nav-number">4.1.2.2.</span> <span class="nav-text">保新机制</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A2%9E%E5%8A%A0%E4%B8%80%E4%B8%AAWindow%EF%BC%9F"><span class="nav-number">4.1.3.</span> <span class="nav-text">增加一个Window？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5%EF%BC%88eviction-policy%EF%BC%89"><span class="nav-number">4.1.4.</span> <span class="nav-text">淘汰策略（eviction policy）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%82%E6%AD%A5%E7%9A%84%E9%AB%98%E6%80%A7%E8%83%BD%E8%AF%BB%E5%86%99"><span class="nav-number">4.2.</span> <span class="nav-text">异步的高性能读写</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#ReadBuffer"><span class="nav-number">4.2.1.</span> <span class="nav-text">ReadBuffer</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#WriteBuffer"><span class="nav-number">4.2.2.</span> <span class="nav-text">WriteBuffer</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TimerWheel"><span class="nav-number">4.3.</span> <span class="nav-text">TimerWheel</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">5.</span> <span class="nav-text">总结</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="nav-number">6.</span> <span class="nav-text">参考资料</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">xuezc</p>
  <div class="site-description" itemprop="description">在这里，你会了解的更多，更透切</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">36</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">15</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">67</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">xuezc</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
