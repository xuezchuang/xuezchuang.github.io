<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.2">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":true,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="HashedWheelTimer时间轮是一个高性能，低消耗的数据结构，它适合用非准实时，延迟的短平快任务，例如心跳检测。">
<meta property="og:type" content="article">
<meta property="og:title" content="HashedWheelTimer时间轮原理分析">
<meta property="og:url" content="http://example.com/posts/ec8df8c/index.html">
<meta property="og:site_name" content="xuezc&#39;s home">
<meta property="og:description" content="HashedWheelTimer时间轮是一个高性能，低消耗的数据结构，它适合用非准实时，延迟的短平快任务，例如心跳检测。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/images/HashedWheelTimer%E6%97%B6%E9%97%B4%E8%BD%AE%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90__0.png">
<meta property="og:image" content="http://example.com/images/HashedWheelTimer%E6%97%B6%E9%97%B4%E8%BD%AE%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90__2.png">
<meta property="og:image" content="http://example.com/images/HashedWheelTimer%E6%97%B6%E9%97%B4%E8%BD%AE%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90__1.png">
<meta property="article:published_time" content="2019-03-28T09:57:00.000Z">
<meta property="article:modified_time" content="2023-03-27T06:18:53.488Z">
<meta property="article:author" content="xuezc">
<meta property="article:tag" content="HashedWheelTimer">
<meta property="article:tag" content="时间轮">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/images/HashedWheelTimer%E6%97%B6%E9%97%B4%E8%BD%AE%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90__0.png">

<link rel="canonical" href="http://example.com/posts/ec8df8c/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>HashedWheelTimer时间轮原理分析 | xuezc's home</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">xuezc's home</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">首页</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/posts/ec8df8c/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="xuezc">
      <meta itemprop="description" content="在这里，你会了解的更多，更透切">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="xuezc's home">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          HashedWheelTimer时间轮原理分析
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-03-28 17:57:00" itemprop="dateCreated datePublished" datetime="2019-03-28T17:57:00+08:00">2019-03-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-03-27 14:18:53" itemprop="dateModified" datetime="2023-03-27T14:18:53+08:00">2023-03-27</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/netty/" itemprop="url" rel="index"><span itemprop="name">netty</span></a>
                </span>
            </span>

          
            <div class="post-description">HashedWheelTimer时间轮是一个高性能，低消耗的数据结构，它适合用非准实时，延迟的短平快任务，例如心跳检测。</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h2><p>时间轮是一种非常惊艳的数据结构。其在Linux内核中使用广泛，是Linux内核定时器的实现方法和基础之一。Netty内部基于时间轮实现了一个HashedWheelTimer来优化I/O超时的检测，本文将详细分析HashedWheelTimer的使用及原理。</p>
<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>由于Netty动辄管理100w+的连接，每一个连接都会有很多超时任务。比如发送超时、心跳检测间隔等，如果每一个定时任务都启动一个Timer，不仅低效，而且会消耗大量的资源。<br>在Netty中的一个典型应用场景是判断某个连接是否idle，如果idle（如客户端由于网络原因导致到服务器的心跳无法送达），则服务器会主动断开连接，释放资源。得益于Netty NIO的优异性能，基于Netty开发的服务器可以维持大量的长连接，单台8核16G的云主机可以同时维持几十万长连接，及时掐掉不活跃的连接就显得尤其重要。</p>
<p>看看官方文档说明：</p>
<blockquote>
<p>A optimized for approximated I/O timeout scheduling.<br>You can increase or decrease the accuracy of the execution timing by</p>
</blockquote>
<ul>
<li>specifying smaller or larger tick duration in the constructor.  In most</li>
<li>network applications, I/O timeout does not need to be accurate.  Therefore,</li>
<li>the default tick duration is 100 milliseconds and you will not need to try</li>
<li>different configurations in most cases.</li>
</ul>
<p>大概意思是一种对“适当”I/O超时调度的优化。因为I/O timeout这种任务对时效性不需要准确。</p>
<p>这种方案也不是Netty凭空造出来的，而是根据George Varghese和Tony Lauck在1996年的论文实现的，有兴趣的可以阅读一下。<br><a target="_blank" rel="noopener" href="http://cseweb.ucsd.edu/users/varghese/PAPERS/twheel.ps.Z">论文下载</a><br><a target="_blank" rel="noopener" href="https://www.cse.wustl.edu/~cdgill/courses/cs6874/TimingWheels.ppt">论文PPT</a></p>
<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>HashedWheelTimer本质是一种类似延迟任务队列的实现，那么它的特点就是上述所说的，适用于对时效性不高的，可快速执行的，大量这样的“小”任务，能够做到高性能，低消耗。<br>例如：</p>
<ul>
<li>心跳检测</li>
<li>session、请求是否timeout<br>业务场景则有：</li>
<li>用户下单后发短信</li>
<li>下单之后15分钟，如果用户不付款就自动取消订单</li>
</ul>
<h2 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h2><p>如果之前没用过，先看看用法有一个大体的感受，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashedWheelTimerTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">CountDownLatch</span> <span class="variable">countDownLatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//定义一个HashedWheelTimer，有16个格的轮子，每一秒走一个一个格子</span></span><br><span class="line">        <span class="type">HashedWheelTimer</span> <span class="variable">timer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashedWheelTimer</span>(<span class="number">1</span>, TimeUnit.SECONDS, <span class="number">16</span>);</span><br><span class="line">        <span class="comment">//把任务加到HashedWheelTimer里，到了延迟的时间就会自动执行</span></span><br><span class="line">        timer.newTimeout((timeout) -&gt; &#123;</span><br><span class="line">            log.info(<span class="string">&quot;task1 execute&quot;</span>);</span><br><span class="line">            countDownLatch.countDown();</span><br><span class="line">        &#125;, <span class="number">500</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">        timer.newTimeout((timeout) -&gt; &#123;</span><br><span class="line">            log.info(<span class="string">&quot;task2 execute&quot;</span>);</span><br><span class="line">            countDownLatch.countDown();</span><br><span class="line">        &#125;, <span class="number">2</span>, TimeUnit.SECONDS);</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        timer.stop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要引入<code>netty-all.jar</code>包<br>使用上跟<code>ScheduledExecutorService</code>差不多。</p>
<h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p>源码基于<code>netty-all.4.1.34.Final</code></p>
<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p>时间轮其实就是一种环形的数据结构，可以想象成时钟，分成很多格子，一个格子代码一段时间（这个时间越短，Timer的精度越高）。并用一个链表报错在该格子上的到期任务，同时一个指针随着时间一格一格转动，并执行相应格子中的到期任务。任务通过取摸决定放入那个格子。如下图所示：</p>
<p><img src="/images/HashedWheelTimer%E6%97%B6%E9%97%B4%E8%BD%AE%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90__0.png" alt="upload successful"></p>
<p>假设一个格子是1秒，则整个wheel能表示的时间段为8s，假如当前指针指向2，此时需要调度一个3s后执行的任务，显然应该加入到(2+3=5)的方格中，指针再走3次就可以执行了；如果任务要在10s后执行，应该等指针走完一个round零2格再执行，因此应放入4，同时将round（1）保存到任务中。检查到期任务时应当只执行round为0的，格子上其他任务的round应减1。</p>
<p>再回头看看构造方法的三个参数分别代表</p>
<ul>
<li>tickDuration<br>每一tick的时间</li>
<li>timeUnit<br>tickDuration的时间单位</li>
<li>ticksPerWheel<br>就是轮子一共有多个格子，即要多少个tick才能走完这个wheel一圈。</li>
</ul>
<p>对于HashedWheelTimer的数据结构在介绍完源码之后有图解。</p>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>HashedWheelTimer整体代码不难，慢慢看应该都可以看懂<br>我们从HashedWheelTimer的构造方法入手，先说明一下</p>
<h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//附上文档说明，自行阅读</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates a new timer.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> threadFactory        a &#123;<span class="doctag">@link</span> ThreadFactory&#125; that creates a</span></span><br><span class="line"><span class="comment"> *                             background &#123;<span class="doctag">@link</span> Thread&#125; which is dedicated to</span></span><br><span class="line"><span class="comment"> *                             &#123;<span class="doctag">@link</span> TimerTask&#125; execution.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> tickDuration         the duration between tick</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> unit                 the time unit of the &#123;<span class="doctag">@code</span> tickDuration&#125;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> ticksPerWheel        the size of the wheel</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> leakDetection        &#123;<span class="doctag">@code</span> true&#125; if leak detection should be enabled always,</span></span><br><span class="line"><span class="comment"> *                             if false it will only be enabled if the worker thread is not</span></span><br><span class="line"><span class="comment"> *                             a daemon thread.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  maxPendingTimeouts  The maximum number of pending timeouts after which call to</span></span><br><span class="line"><span class="comment"> *                             &#123;<span class="doctag">@code</span> newTimeout&#125; will result in</span></span><br><span class="line"><span class="comment"> *                             &#123;<span class="doctag">@link</span> java.util.concurrent.RejectedExecutionException&#125;</span></span><br><span class="line"><span class="comment"> *                             being thrown. No maximum pending timeouts limit is assumed if</span></span><br><span class="line"><span class="comment"> *                             this value is 0 or negative.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException     if either of &#123;<span class="doctag">@code</span> threadFactory&#125; and &#123;<span class="doctag">@code</span> unit&#125; is &#123;<span class="doctag">@code</span> null&#125;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalArgumentException if either of &#123;<span class="doctag">@code</span> tickDuration&#125; and &#123;<span class="doctag">@code</span> ticksPerWheel&#125; is &amp;lt;= 0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//threadFactory默认是用Executors.defaultThreadFactory()，太懒了</span></span><br><span class="line"><span class="comment">//tickDuration，unit，ticksPerWheel核心参数，之前已经说过了</span></span><br><span class="line"><span class="comment">//leakDetection内存泄漏检查</span></span><br><span class="line"><span class="comment">//maxPendingTimeouts准备执行的任务数，默认是-1，即不限制。如果并发量真的很高，可以设置一下，防止OOM</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashedWheelTimer</span><span class="params">(</span></span><br><span class="line"><span class="params">        ThreadFactory threadFactory,</span></span><br><span class="line"><span class="params">        <span class="type">long</span> tickDuration, TimeUnit unit, <span class="type">int</span> ticksPerWheel, <span class="type">boolean</span> leakDetection,</span></span><br><span class="line"><span class="params">        <span class="type">long</span> maxPendingTimeouts)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (threadFactory == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>(<span class="string">&quot;threadFactory&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (unit == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>(<span class="string">&quot;unit&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (tickDuration &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;tickDuration must be greater than 0: &quot;</span> + tickDuration);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ticksPerWheel &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;ticksPerWheel must be greater than 0: &quot;</span> + ticksPerWheel);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化时间轮（1）</span></span><br><span class="line">    wheel = createWheel(ticksPerWheel);</span><br><span class="line">    mask = wheel.length - <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">this</span>.tickDuration = unit.toNanos(tickDuration);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//要求tickDuration * wheel.length &lt; Long.MAX_VALUE，我猜测是因为担心有类似的计算而导致溢出（但实际我没找到）</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.tickDuration &gt;= Long.MAX_VALUE / wheel.length) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(String.format(</span><br><span class="line">                <span class="string">&quot;tickDuration: %d (expected: 0 &lt; tickDuration in nanos &lt; %d&quot;</span>,</span><br><span class="line">                tickDuration, Long.MAX_VALUE / wheel.length));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建Work执行线程（2）</span></span><br><span class="line">    workerThread = threadFactory.newThread(worker);</span><br><span class="line">    <span class="comment">//默认是启动内存泄露检测（我还不是很清楚具体原理）</span></span><br><span class="line">    leak = leakDetection || !workerThread.isDaemon() ? leakDetector.track(<span class="built_in">this</span>) : <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.maxPendingTimeouts = maxPendingTimeouts;</span><br><span class="line">    <span class="comment">//HashedWheelTimer实例数限制，因为HashedWheelTimer是一个非常消耗内存的对象，如果超过64个则会警告</span></span><br><span class="line">    <span class="keyword">if</span> (INSTANCE_COUNTER.incrementAndGet() &gt; INSTANCE_COUNT_LIMIT &amp;&amp;</span><br><span class="line">        WARNED_TOO_MANY_INSTANCES.compareAndSet(<span class="literal">false</span>, <span class="literal">true</span>)) &#123;</span><br><span class="line">        reportTooManyInstances();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="createWheel"><a href="#createWheel" class="headerlink" title="createWheel"></a>createWheel</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> HashedWheelBucket[] createWheel(<span class="type">int</span> ticksPerWheel) &#123;</span><br><span class="line">    <span class="keyword">if</span> (ticksPerWheel &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(</span><br><span class="line">                <span class="string">&quot;ticksPerWheel must be greater than 0: &quot;</span> + ticksPerWheel);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ticksPerWheel &gt; <span class="number">1073741824</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(</span><br><span class="line">                <span class="string">&quot;ticksPerWheel may not be greater than 2^30: &quot;</span> + ticksPerWheel);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//格子数向2的N次方数靠齐</span></span><br><span class="line">    ticksPerWheel = normalizeTicksPerWheel(ticksPerWheel);</span><br><span class="line">    HashedWheelBucket[] wheel = <span class="keyword">new</span> <span class="title class_">HashedWheelBucket</span>[ticksPerWheel];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; wheel.length; i ++) &#123;</span><br><span class="line">        <span class="comment">//初始化每一个bucket</span></span><br><span class="line">        wheel[i] = <span class="keyword">new</span> <span class="title class_">HashedWheelBucket</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> wheel;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//循环直到小于2的N次方</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">normalizeTicksPerWheel</span><span class="params">(<span class="type">int</span> ticksPerWheel)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">normalizedTicksPerWheel</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (normalizedTicksPerWheel &lt; ticksPerWheel) &#123;</span><br><span class="line">        normalizedTicksPerWheel &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> normalizedTicksPerWheel;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>wheel其实是一个bucket数组</p>
<h4 id="HashedWheelBucket"><a href="#HashedWheelBucket" class="headerlink" title="HashedWheelBucket"></a>HashedWheelBucket</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Bucket that stores HashedWheelTimeouts. These are stored in a linked-list like datastructure to allow easy</span></span><br><span class="line"><span class="comment">* removal of HashedWheelTimeouts in the middle. Also the HashedWheelTimeout act as nodes themself and so no</span></span><br><span class="line"><span class="comment">* extra object creation is needed.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">HashedWheelBucket</span> &#123;</span><br><span class="line">    <span class="comment">// Used for the linked-list datastructure</span></span><br><span class="line">    <span class="keyword">private</span> HashedWheelTimeout head;</span><br><span class="line">    <span class="keyword">private</span> HashedWheelTimeout tail;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>bucket的结构是一个带有头节点指针和尾节点指针的linked-list</p>
<h3 id="newTimeout"><a href="#newTimeout" class="headerlink" title="newTimeout"></a>newTimeout</h3><p>HashedWheelTimer初始化后，看看怎样增加一个任务（在HashedWheelTimer内部统一叫HashedWheelTimeout，缩写timeout，从名字已经可以看出HashedWheelTimer的作用）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Timeout <span class="title function_">newTimeout</span><span class="params">(TimerTask task, <span class="type">long</span> delay, TimeUnit unit)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>(<span class="string">&quot;task&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (unit == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>(<span class="string">&quot;unit&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//记录代处理数，这个数字没有实际作用，或可用于监控</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">pendingTimeoutsCount</span> <span class="operator">=</span> pendingTimeouts.incrementAndGet();</span><br><span class="line">    <span class="comment">//如果大于maxPendingTimeouts则报错，默认-1，即不限制</span></span><br><span class="line">    <span class="keyword">if</span> (maxPendingTimeouts &gt; <span class="number">0</span> &amp;&amp; pendingTimeoutsCount &gt; maxPendingTimeouts) &#123;</span><br><span class="line">        pendingTimeouts.decrementAndGet();</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RejectedExecutionException</span>(<span class="string">&quot;Number of pending timeouts (&quot;</span></span><br><span class="line">            + pendingTimeoutsCount + <span class="string">&quot;) is greater than or equal to maximum allowed pending &quot;</span></span><br><span class="line">            + <span class="string">&quot;timeouts (&quot;</span> + maxPendingTimeouts + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//（1）</span></span><br><span class="line">    start();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//计算这个timeout的执行时间，公式=当前时间 + 延迟时间 - wheelTimer的启动时间，单位纳秒，很直观吧</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">deadline</span> <span class="operator">=</span> System.nanoTime() + unit.toNanos(delay) - startTime;</span><br><span class="line">    <span class="comment">//初始化timeout</span></span><br><span class="line">    <span class="type">HashedWheelTimeout</span> <span class="variable">timeout</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashedWheelTimeout</span>(<span class="built_in">this</span>, task, deadline);</span><br><span class="line">    <span class="comment">//timeouts是一个MpscQueue队列。这里注意了，新加入的timeout不是立即加到wheel中的，而是先加入到一个队列，在tick的时候再从队列取出来加入到wheel。</span></span><br><span class="line">    <span class="comment">//原因是，我猜测一是做缓冲作用，二是避免在插入timeout和执行timeout时有并发的冲突，特别是对linked-list的操作，如果采用加锁的话，而执行该bucket所有timeout的时间不能保证，可能反而会阻塞到用户。</span></span><br><span class="line">    timeouts.add(timeout);</span><br><span class="line">    <span class="keyword">return</span> timeout;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//（1）</span></span><br><span class="line"><span class="comment">//start方法为了保证wheelTimer在运行的状态（如果是关闭状态，那么直接抛异常出去），且wheelTimer已经初始化完成</span></span><br><span class="line"><span class="comment">//大家是不是很好奇wheelTimer的初始化为什么要在newTimeout，即加入第一个timeout后才去做。可以沿着延迟初始化或懒加载的思路去想，如果一个HashedWheelTimer初始化后一直没有timeout加入，在那里空转而白白浪费CPU资源就不好了。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> (WORKER_STATE_UPDATER.get(<span class="built_in">this</span>)) &#123;</span><br><span class="line">        <span class="keyword">case</span> WORKER_STATE_INIT:</span><br><span class="line">            <span class="keyword">if</span> (WORKER_STATE_UPDATER.compareAndSet(<span class="built_in">this</span>, WORKER_STATE_INIT, WORKER_STATE_STARTED)) &#123;</span><br><span class="line">                <span class="comment">//启动Worker</span></span><br><span class="line">                workerThread.start();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> WORKER_STATE_STARTED:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> WORKER_STATE_SHUTDOWN:</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;cannot be started once stopped&quot;</span>);</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Invalid WorkerState&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//因为Worker是异步执行的，会一直等待Worker的初始化</span></span><br><span class="line">    <span class="keyword">while</span> (startTime == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//是一个CountDownLatch</span></span><br><span class="line">            startTimeInitialized.await();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException ignore) &#123;</span><br><span class="line">            <span class="comment">// Ignore - it will be ready very soon.</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="HashedWheelTimeout"><a href="#HashedWheelTimeout" class="headerlink" title="HashedWheelTimeout"></a>HashedWheelTimeout</h4><p>timeout的结构</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">HashedWheelTimeout</span> <span class="keyword">implements</span> <span class="title class_">Timeout</span> &#123;</span><br><span class="line">    <span class="comment">//timeout的状态有初始化，取消，已执行</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">ST_INIT</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">ST_CANCELLED</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">ST_EXPIRED</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">    <span class="comment">//用来支持CAS操作原子类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicIntegerFieldUpdater&lt;HashedWheelTimeout&gt; STATE_UPDATER =</span><br><span class="line">            AtomicIntegerFieldUpdater.newUpdater(HashedWheelTimeout.class, <span class="string">&quot;state&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//所属timer</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> HashedWheelTimer timer;</span><br><span class="line">    <span class="comment">//需要执行的Runnable</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> TimerTask task;</span><br><span class="line">    <span class="comment">//执行时间</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">long</span> deadline;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings(&#123;&quot;unused&quot;, &quot;FieldMayBeFinal&quot;, &quot;RedundantFieldInitialization&quot; &#125;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> <span class="variable">state</span> <span class="operator">=</span> ST_INIT;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//时间轮的层数</span></span><br><span class="line">    <span class="type">long</span> remainingRounds;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在linked-list中该节点指向的前后节点</span></span><br><span class="line">    HashedWheelTimeout next;</span><br><span class="line">    HashedWheelTimeout prev;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The bucket to which the timeout was added</span></span><br><span class="line">    HashedWheelBucket bucket;</span><br><span class="line"></span><br><span class="line">    HashedWheelTimeout(HashedWheelTimer timer, TimerTask task, <span class="type">long</span> deadline) &#123;</span><br><span class="line">        <span class="built_in">this</span>.timer = timer;</span><br><span class="line">        <span class="built_in">this</span>.task = task;</span><br><span class="line">        <span class="built_in">this</span>.deadline = deadline;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Worker-run"><a href="#Worker-run" class="headerlink" title="Worker run"></a>Worker run</h3><p>一个HashedWheelTimer只有一个Worker线程。看看Worker的初始化</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Worker</span> <span class="variable">worker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Worker</span>();</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>Worker继承Runnable，我们看run方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//获取启动的时间作为开始时间</span></span><br><span class="line">        startTime = System.nanoTime();</span><br><span class="line">        <span class="keyword">if</span> (startTime == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// We use 0 as an indicator for the uninitialized value here, so make sure it&#x27;s not 0 when initialized.</span></span><br><span class="line">            startTime = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Notify the other threads waiting for the initialization at start().</span></span><br><span class="line">        startTimeInitialized.countDown();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="comment">//等待下一个tick（1）</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">long</span> <span class="variable">deadline</span> <span class="operator">=</span> waitForNextTick();</span><br><span class="line">            <span class="keyword">if</span> (deadline &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//找到该处理的bucket下标，因为wheel.length是2的N次方，mask为length - 1，所以这里相当于取模操作，性能比%高</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> (<span class="type">int</span>) (tick &amp; mask);</span><br><span class="line">                <span class="comment">//处理掉已经取消的timeout（2）</span></span><br><span class="line">                processCancelledTasks();</span><br><span class="line">                <span class="comment">//找到当前tick对应哪个bucket</span></span><br><span class="line">                <span class="type">HashedWheelBucket</span> <span class="variable">bucket</span> <span class="operator">=</span></span><br><span class="line">                        wheel[idx];</span><br><span class="line">                <span class="comment">//把队列的timeout放到wheel里（3）</span></span><br><span class="line">                transferTimeoutsToBuckets();</span><br><span class="line">                <span class="comment">//处理当前bucket所有的timeout（4）</span></span><br><span class="line">                bucket.expireTimeouts(deadline);</span><br><span class="line">                <span class="comment">//tick加一</span></span><br><span class="line">                tick++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//注意一下处理的顺序，也讲究的，先处理掉被取消的timeout，再把队列的加进来，再处理，后面两步不能反转，因为有可能队列里的timeout是下一tick执行的</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//循环直到wheelTimer被关闭</span></span><br><span class="line">        &#125; <span class="keyword">while</span> (WORKER_STATE_UPDATER.get(HashedWheelTimer.<span class="built_in">this</span>) == WORKER_STATE_STARTED);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//wheelTimer被关闭后的处理</span></span><br><span class="line">        <span class="comment">//取出每一个bucket里还没被执行的timeout，放到unprocessedTimeouts中</span></span><br><span class="line">        <span class="keyword">for</span> (HashedWheelBucket bucket: wheel) &#123;</span><br><span class="line">            bucket.clearTimeouts(unprocessedTimeouts);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//把队列里的timeout放到unprocessedTimeouts中</span></span><br><span class="line">        <span class="comment">//PS：这个unprocessedTimeouts暂时只是做记录用，做监控时或可用到</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="type">HashedWheelTimeout</span> <span class="variable">timeout</span> <span class="operator">=</span> timeouts.poll();</span><br><span class="line">            <span class="keyword">if</span> (timeout == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!timeout.isCancelled()) &#123;</span><br><span class="line">                unprocessedTimeouts.add(timeout);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//还要处理掉中间被取消的timeout</span></span><br><span class="line">        processCancelledTasks();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//（1）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> <span class="title function_">waitForNextTick</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//计算下一个tick的时间，很简单一看就懂</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">deadline</span> <span class="operator">=</span> tickDuration * (tick + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">long</span> <span class="variable">currentTime</span> <span class="operator">=</span> System.nanoTime() - startTime;</span><br><span class="line">            <span class="comment">//根据当前计算需要sleep的时间。这里加了999999是因为向上取整了1毫秒，假如距离下一个tick的时间为2000010纳秒，那如果sleep 2毫秒是不够的，所以需要多sleep 1毫秒。</span></span><br><span class="line">            <span class="type">long</span> <span class="variable">sleepTimeMs</span> <span class="operator">=</span> (deadline - currentTime + <span class="number">999999</span>) / <span class="number">1000000</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//sleepTimeMs &lt;=0 说明下一个tick的时间到了，说明上一个tick执行的时间“太久”了，所以直接返回就好了，不需要sleep</span></span><br><span class="line">            <span class="keyword">if</span> (sleepTimeMs &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//currentTime == Long.MIN_VALUE 这个判断不是很理解</span></span><br><span class="line">                <span class="keyword">if</span> (currentTime == Long.MIN_VALUE) &#123;</span><br><span class="line">                    <span class="keyword">return</span> -Long.MAX_VALUE;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> currentTime;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Check if we run on windows, as if thats the case we will need</span></span><br><span class="line">            <span class="comment">// to round the sleepTime as workaround for a bug that only affect</span></span><br><span class="line">            <span class="comment">// the JVM if it runs on windows.</span></span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            <span class="comment">// See https://github.com/netty/netty/issues/356</span></span><br><span class="line">            <span class="comment">//这里是为了处理在windows系统上的一个bug，如果sleep不够10ms则要取整</span></span><br><span class="line">            <span class="keyword">if</span> (PlatformDependent.isWindows()) &#123;</span><br><span class="line">                sleepTimeMs = sleepTimeMs / <span class="number">10</span> * <span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//直接sleep等待</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(sleepTimeMs);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException ignored) &#123;</span><br><span class="line">                <span class="comment">//Worker被中断，如果是关闭了则返回负数，表示不会执行下一个tick</span></span><br><span class="line">                <span class="keyword">if</span> (WORKER_STATE_UPDATER.get(HashedWheelTimer.<span class="built_in">this</span>) == WORKER_STATE_SHUTDOWN) &#123;</span><br><span class="line">                    <span class="keyword">return</span> Long.MIN_VALUE;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//（2）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">processCancelledTasks</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">//cancelledTimeouts也是一个MpscQueue，调用timeout的cancel方法会把timeout加进去</span></span><br><span class="line">            <span class="comment">//把取消的timeout取出来</span></span><br><span class="line">            <span class="type">HashedWheelTimeout</span> <span class="variable">timeout</span> <span class="operator">=</span> cancelledTimeouts.poll();</span><br><span class="line">            <span class="keyword">if</span> (timeout == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// all processed</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//移除掉（2.1）</span></span><br><span class="line">                timeout.remove();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                <span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">                    logger.warn(<span class="string">&quot;An exception was thrown while process a cancellation task&quot;</span>, t);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//（2.1）</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">HashedWheelBucket</span> <span class="variable">bucket</span> <span class="operator">=</span> <span class="built_in">this</span>.bucket;</span><br><span class="line">        <span class="keyword">if</span> (bucket != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//调用bucket的remove方法（2.2）</span></span><br><span class="line">            bucket.remove(<span class="built_in">this</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            timer.pendingTimeouts.decrementAndGet();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//（2.2）</span></span><br><span class="line">    <span class="comment">//类似链表删除节点的操作</span></span><br><span class="line">    <span class="keyword">public</span> HashedWheelTimeout <span class="title function_">remove</span><span class="params">(HashedWheelTimeout timeout)</span> &#123;</span><br><span class="line">        <span class="type">HashedWheelTimeout</span> <span class="variable">next</span> <span class="operator">=</span> timeout.next;</span><br><span class="line">        <span class="comment">// remove timeout that was either processed or cancelled by updating the linked-list</span></span><br><span class="line">        <span class="keyword">if</span> (timeout.prev != <span class="literal">null</span>) &#123;</span><br><span class="line">            timeout.prev.next = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (timeout.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            timeout.next.prev = timeout.prev;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (timeout == head) &#123;</span><br><span class="line">            <span class="comment">// if timeout is also the tail we need to adjust the entry too</span></span><br><span class="line">            <span class="keyword">if</span> (timeout == tail) &#123;</span><br><span class="line">                tail = <span class="literal">null</span>;</span><br><span class="line">                head = <span class="literal">null</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                head = next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (timeout == tail) &#123;</span><br><span class="line">            <span class="comment">// if the timeout is the tail modify the tail to be the prev node.</span></span><br><span class="line">            tail = timeout.prev;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// null out prev, next and bucket to allow for GC.</span></span><br><span class="line">        timeout.prev = <span class="literal">null</span>;</span><br><span class="line">        timeout.next = <span class="literal">null</span>;</span><br><span class="line">        timeout.bucket = <span class="literal">null</span>;</span><br><span class="line">        timeout.timer.pendingTimeouts.decrementAndGet();</span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//（3）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">transferTimeoutsToBuckets</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//最多取队列的100000的元素出来</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">            <span class="type">HashedWheelTimeout</span> <span class="variable">timeout</span> <span class="operator">=</span> timeouts.poll();</span><br><span class="line">            <span class="keyword">if</span> (timeout == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// all processed</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果timeout被取消了则不做处理</span></span><br><span class="line">            <span class="keyword">if</span> (timeout.state() == HashedWheelTimeout.ST_CANCELLED) &#123;</span><br><span class="line">                <span class="comment">// Was cancelled in the meantime.</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//计算位于实践论的层数</span></span><br><span class="line">            <span class="type">long</span> <span class="variable">calculated</span> <span class="operator">=</span> timeout.deadline / tickDuration;</span><br><span class="line">            timeout.remainingRounds = (calculated - tick) / wheel.length;</span><br><span class="line">            <span class="comment">//就是timeout已经到期了，也不能放到之前的tick中</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">long</span> <span class="variable">ticks</span> <span class="operator">=</span> Math.max(calculated, tick); <span class="comment">// Ensure we don&#x27;t schedule for past.</span></span><br><span class="line">            <span class="comment">//计算所在bucket下标，并放进去</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">stopIndex</span> <span class="operator">=</span> (<span class="type">int</span>) (ticks &amp; mask);</span><br><span class="line"></span><br><span class="line">            <span class="type">HashedWheelBucket</span> <span class="variable">bucket</span> <span class="operator">=</span> wheel[stopIndex];</span><br><span class="line">            <span class="comment">//又是类似链表插入节点的操作</span></span><br><span class="line">            bucket.addTimeout(timeout);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//（4）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">expireTimeouts</span><span class="params">(<span class="type">long</span> deadline)</span> &#123;</span><br><span class="line">        <span class="type">HashedWheelTimeout</span> <span class="variable">timeout</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="comment">//把bucket的所有timeout取出来执行</span></span><br><span class="line">        <span class="keyword">while</span> (timeout != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">HashedWheelTimeout</span> <span class="variable">next</span> <span class="operator">=</span> timeout.next;</span><br><span class="line">            <span class="keyword">if</span> (timeout.remainingRounds &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                next = remove(timeout);</span><br><span class="line">                <span class="keyword">if</span> (timeout.deadline &lt;= deadline) &#123;</span><br><span class="line">                    <span class="comment">//timeout的真正执行</span></span><br><span class="line">                    timeout.expire();</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// The timeout was placed into a wrong slot. This should never happen.</span></span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(String.format(</span><br><span class="line">                            <span class="string">&quot;timeout.deadline (%d) &gt; deadline (%d)&quot;</span>, timeout.deadline, deadline));</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="comment">//该timeout被取消了则移除掉    </span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (timeout.isCancelled()) &#123;</span><br><span class="line">                next = remove(timeout);</span><br><span class="line">            <span class="comment">//否则层数减一，等待下一轮的到来</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                timeout.remainingRounds --;</span><br><span class="line">            &#125;</span><br><span class="line">            timeout = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="图解"><a href="#图解" class="headerlink" title="图解"></a>图解</h3><p>画了个图给大家体会一下<br><img src="/images/HashedWheelTimer%E6%97%B6%E9%97%B4%E8%BD%AE%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90__2.png" alt="upload successful"></p>
<h3 id="MpscQueue队列"><a href="#MpscQueue队列" class="headerlink" title="MpscQueue队列"></a>MpscQueue队列</h3><p>HashedWheelTimer用到的<code>timeouts</code>和<code>cancelledTimeouts</code>都是一种<code>MpscQueue</code>队列的数据结构。<br>MpscQueue全称Multi-Producer Single-Consumer Queue，从名字看出，是一种适合于多个生产者，单个消费者的高并发场景的高性能的，无锁的队列，原来Netty是自己实现了一个，但在最新的版本用了JCTools的，大家有兴趣可以了解一下。</p>
<h3 id="多层时间轮"><a href="#多层时间轮" class="headerlink" title="多层时间轮"></a>多层时间轮</h3><p>当时间跨度很大时，提升单层时间轮的 tickDuration 可以减少空转次数，但会导致时间精度变低，层级时间轮既可以避免精度降低，又避免了指针空转的次数。如果有时间跨度较长的定时任务，则可以交给层级时间轮去调度。<br>设想一下一个定时了 3 天，10 小时，50 分，30 秒的定时任务，在 tickDuration = 1s 的单层时间轮中，需要经过：3246060+106060+5060+30 次指针的拨动才能被执行。但在 wheel1 tickDuration = 1 天，wheel2 tickDuration = 1 小时，wheel3 tickDuration = 1 分，wheel4 tickDuration = 1 秒 的四层时间轮中，只需要经过 3+10+50+30 次指针的拨动。</p>
<p>如图所示:<br><img src="/images/HashedWheelTimer%E6%97%B6%E9%97%B4%E8%BD%AE%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90__1.png" alt="upload successful"></p>
<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p>HashedWheelTimer也有一些缺点，在使用场景上要注意一下</p>
<ul>
<li>Netty的HashedWheelTimer只支持单层的时间轮</li>
<li>当前一个任务执行时间过长的时候，会影响后续任务的到期执行时间的，也就是说其中的任务是串行执行的，所以，要求里面的任务都要短平快</li>
</ul>
<h2 id="延迟任务方案对比"><a href="#延迟任务方案对比" class="headerlink" title="延迟任务方案对比"></a>延迟任务方案对比</h2><p>HashedWheelTimer本质上也是一个延迟队列，我们跟其他延迟类解决方案对比一下</p>
<ul>
<li><p>数据库轮询<br>比较常用的一种方法，数据先保存在数据库中，然后启动一个定时Job，根据时间或状态把数据捞出来，处理后再更新回数据库。这种方式很简单，不会引入其他的技术，开发周期短。如果数据量比较大，千万级甚至更多，插入频率很高的话，上面的方式在性能上会出现一些问题，查找和更新对会占用很多时间，轮询频率高的话甚至会影响数据入库。如果数据量进一步增大，那扫数据库肯定就不行了。另一方面，对于订单这类数据，我们也许会遇到分库分表，那上述方案就会变得过于复杂，得不偿失。<br>不过，优点是数据得到持久化，有问题可以查看。</p>
</li>
<li><p>DelayQueue<br>DelayQueue本质是PriorityQueue，每次插入或删除任务都要调整堆，复杂度是O(logN)，相对HashedWheelTimer的O(1)来说有性能消耗。</p>
</li>
<li><p>ScheduledExecutorService<br>其本质也是类似DelayQueue，不过ScheduledExecutorService是多线程的方式执行，可以基本保证其他任务的准时进行。ScheduledExecutorService封装较好，方便使用，还支持周期性任务。</p>
</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>HashedWheelTimer时间轮是一个高性能，低消耗的数据结构，它适合用非准实时，延迟的短平快任务，例如心跳检测。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a target="_blank" rel="noopener" href="https://zacard.net/2016/12/02/netty-hashedwheeltimer/">https://zacard.net/2016/12/02/netty-hashedwheeltimer/</a><br><a target="_blank" rel="noopener" href="https://www.ctolib.com/topics-113116.html">https://www.ctolib.com/topics-113116.html</a><br><a target="_blank" rel="noopener" href="https://www.cnkirito.moe/timer/">https://www.cnkirito.moe/timer/</a></p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/HashedWheelTimer/" rel="tag"># HashedWheelTimer</a>
              <a href="/tags/%E6%97%B6%E9%97%B4%E8%BD%AE/" rel="tag"># 时间轮</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/posts/e31dfd0e/" rel="prev" title="Slf4j适配日志原理">
      <i class="fa fa-chevron-left"></i> Slf4j适配日志原理
    </a></div>
      <div class="post-nav-item">
    <a href="/posts/dfdb52be/" rel="next" title="AQS">
      AQS <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A6%82%E8%A6%81"><span class="nav-number">1.</span> <span class="nav-text">概要</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%83%8C%E6%99%AF"><span class="nav-number">2.</span> <span class="nav-text">背景</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">3.</span> <span class="nav-text">应用场景</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8"><span class="nav-number">4.</span> <span class="nav-text">简单使用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="nav-number">5.</span> <span class="nav-text">实现原理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">5.1.</span> <span class="nav-text">数据结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">5.2.</span> <span class="nav-text">初始化</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="nav-number">5.2.1.</span> <span class="nav-text">构造方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#createWheel"><span class="nav-number">5.2.2.</span> <span class="nav-text">createWheel</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#HashedWheelBucket"><span class="nav-number">5.2.3.</span> <span class="nav-text">HashedWheelBucket</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#newTimeout"><span class="nav-number">5.3.</span> <span class="nav-text">newTimeout</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#HashedWheelTimeout"><span class="nav-number">5.3.1.</span> <span class="nav-text">HashedWheelTimeout</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Worker-run"><span class="nav-number">5.4.</span> <span class="nav-text">Worker run</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%BE%E8%A7%A3"><span class="nav-number">5.5.</span> <span class="nav-text">图解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MpscQueue%E9%98%9F%E5%88%97"><span class="nav-number">5.6.</span> <span class="nav-text">MpscQueue队列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E5%B1%82%E6%97%B6%E9%97%B4%E8%BD%AE"><span class="nav-number">5.7.</span> <span class="nav-text">多层时间轮</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BC%BA%E7%82%B9"><span class="nav-number">6.</span> <span class="nav-text">缺点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BB%B6%E8%BF%9F%E4%BB%BB%E5%8A%A1%E6%96%B9%E6%A1%88%E5%AF%B9%E6%AF%94"><span class="nav-number">7.</span> <span class="nav-text">延迟任务方案对比</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">8.</span> <span class="nav-text">总结</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="nav-number">9.</span> <span class="nav-text">参考资料</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">xuezc</p>
  <div class="site-description" itemprop="description">在这里，你会了解的更多，更透切</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">36</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">15</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">67</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">xuezc</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
